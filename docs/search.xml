<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android 指定 DNS （为什么新用户安装完你的App后，与Api服务连接失败？）</title>
    <url>/2019/07/16/android-custom-dns/</url>
    <content><![CDATA[<blockquote>
<p>过去一直有个问题：发现我的新用户在安装完App后，打开时提示没有网络（连接到我的Api服务器失败）<br><br>直到今天翻qiniu的SDK时才明白过来，问题可能在<strong>DNS</strong><br><br>七牛的SDK一直使用了一个叫<code>HappyDNS</code>的一个库。我一直以为这是“脱裤子放屁”。<br><br>直到今天才明白这中间的“中国特色”</p>
</blockquote>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>开发工具：Android Studio</li>
<li>语言：Kotlin</li>
<li>依赖包：<ul>
<li>com.squareup.okhttp3:okhttp:3.14.2</li>
<li>com.qiniu:happy-dns:0.2.13</li>
</ul>
</li>
</ul>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">                             .dns &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (it == <span class="string">&quot;my.api.host.domain.name&quot;</span>) &#123;</span><br><span class="line">                                     InetAddress.getAllByName(Config.SERVER_IP).toMutableList()</span><br><span class="line">                                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                     <span class="keyword">try</span>&#123;</span><br><span class="line">                                         <span class="keyword">val</span> resolvers = mutableListOf&lt;IResolver&gt;()</span><br><span class="line">                                         <span class="keyword">try</span>&#123;</span><br><span class="line">                                             resolvers.add(Resolver(InetAddress.getByName(<span class="string">&quot;119.29.29.29&quot;</span>)))</span><br><span class="line">                                         &#125;<span class="keyword">catch</span> (e:Exception)&#123;&#125;</span><br><span class="line">                                         <span class="keyword">try</span>&#123;</span><br><span class="line">                                             resolvers.add(Resolver(InetAddress.getByName(<span class="string">&quot;114.114.114.114&quot;</span>)))</span><br><span class="line">                                         &#125;<span class="keyword">catch</span> (e:Exception)&#123;&#125;</span><br><span class="line">                                         <span class="keyword">try</span>&#123;</span><br><span class="line">                                             resolvers.add(Resolver(InetAddress.getByName(<span class="string">&quot;8.8.8.8&quot;</span>)))</span><br><span class="line">                                         &#125;<span class="keyword">catch</span> (e:Exception)&#123;&#125;</span><br><span class="line">                                         <span class="keyword">if</span> (resolvers.size == <span class="number">0</span>) <span class="keyword">throw</span> UnknownHostException(<span class="string">&quot;<span class="variable">$it</span> resolver fail&quot;</span>)</span><br><span class="line">                                         DnsManager(NetworkInfo.normal,resolvers.toTypedArray()).queryInetAdress(Domain(it)).toMutableList()</span><br><span class="line">                                     &#125;<span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">                                         Dns.SYSTEM.lookup(it)</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;.build()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Android</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeBSD 12 构建 mosquitto v2.0.7 + websockets + TLS + PostgreSQL认证</title>
    <url>/2021/02/01/build-mosquitto-on-freebsd/</url>
    <content><![CDATA[<h1 id="MQTT服务器需求"><a href="#MQTT服务器需求" class="headerlink" title="MQTT服务器需求"></a>MQTT服务器需求</h1><ul>
<li>支持Websocket</li>
<li>支持命令行输出json输出</li>
<li>支持通过PostgreSQL认证用户</li>
</ul>
<pre class="mermaid">graph LR
pg[(PostgreSQL)]
auth(Auth plugin)
mos([Mosquitto])
ws(LibWebsockets)
c(MQTT Client)
b(Web Browser)

click auth "https://github.com/iegomez/mosquitto-go-auth" _blank
click pg "https://www.postgresql.org/" "PostgreSQL 官方" _blank
click mos "https://mosquitto.org/" "mosquitto 官方" _blank

pg --- auth
auth --- mos
mos --- ws
ws --- b
mos --- c</pre>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="mosquitto-资源"><a href="#mosquitto-资源" class="headerlink" title="mosquitto 资源"></a>mosquitto 资源</h2><p>官网源码包下载地址： <a class="link"   href="https://mosquitto.org/download/" >https://mosquitto.org/download/<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>当前最新版本2.0.6： <a class="link"   href="https://mosquitto.org/files/source/mosquitto-2.0.7.tar.gz" >https://mosquitto.org/files/source/mosquitto-2.0.7.tar.gz<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="官方推荐认证扩展"><a href="#官方推荐认证扩展" class="headerlink" title="官方推荐认证扩展"></a>官方推荐认证扩展</h2><p><a class="link"   href="https://github.com/iegomez/mosquitto-go-auth" >https://github.com/iegomez/mosquitto-go-auth<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="编译-mosquitto"><a href="#编译-mosquitto" class="headerlink" title="编译 mosquitto"></a>编译 mosquitto</h2><h3 id="安装依赖："><a href="#安装依赖：" class="headerlink" title="安装依赖："></a>安装依赖：</h3><ul>
<li><code>gmake</code> 编译工具</li>
<li><code>cmake</code> 编译工具</li>
<li><code>libcjson</code> 命令行支持json格式输出依赖</li>
<li><code>libwebsockets</code> websocket依赖</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg install gmake libcjson</span><br></pre></td></tr></table></figure>
<p>根据开发者描述:<a class="link"   href="https://github.com/eclipse/mosquitto/issues/2060" >https://github.com/eclipse/mosquitto/issues/2060<i class="fas fa-external-link-alt"></i></a><br><code>libwebsockets</code> 高于<code>v2.4.2</code>后会默认关闭<code>LWS_WITH_EXTERNAL_POLL</code>选项.导致<code>mosquitto</code>功能受损.</p>
<p>所以,要么选择低版本的<code>libwebsockets</code>,要么重新手动编译高版本.</p>
<p>这里选择重新手动编译高版本,开启<code>LWS_WITH_EXTERNAL_POLL</code>选项.</p>
<ul>
<li><code>cmake</code> 编译:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://libwebsockets.org/repo/libwebsockets</span><br><span class="line">cd libwebsockets</span><br><span class="line">git checkout v4.1.6</span><br><span class="line">cd ..</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DLWS_WITH_EXTERNAL_POLL=ON ../libwebsockets</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="解压源码包。配置config-mk"><a href="#解压源码包。配置config-mk" class="headerlink" title="解压源码包。配置config.mk"></a>解压源码包。配置<code>config.mk</code></h3></li>
</ul>
<ul>
<li>WITH_WEBSOCKETS:=no -&gt; yes</li>
<li>WITH_CJSON:=yes</li>
</ul>
<h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><ul>
<li><code>gmake</code> 编译:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gmake CFLAGS=&quot;-I/usr/local/include&quot; LDFLAGS=&quot;-L/usr/local/lib&quot;</span><br><span class="line">gmake install</span><br></pre></td></tr></table></figure></li>
<li><code>cmake</code> 编译:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr/local -DOPENSSL_ROOT_DIR=/usr/local/opt/openssl -DWITH_WEBSOCKETS=ON -E env LDFLAGS=&quot;-L/usr/local/lib&quot; -DCMAKE_C_FLAGS=&quot;-I/usr/local/include&quot; ../mosquitto</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="编译-mosquitto-go-auth"><a href="#编译-mosquitto-go-auth" class="headerlink" title="编译 mosquitto-go-auth"></a>编译 mosquitto-go-auth</h2></li>
</ul>
<h3 id="安装依赖：-1"><a href="#安装依赖：-1" class="headerlink" title="安装依赖："></a>安装依赖：</h3><ul>
<li><code>go</code> 编译工具，此为<code>golang</code>源码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg install go</span><br></pre></td></tr></table></figure>
<h3 id="配置国内源"><a href="#配置国内源" class="headerlink" title="配置国内源"></a>配置国内源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<h3 id="编译-2"><a href="#编译-2" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gmake</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mosquitto</tag>
        <tag>mqtt</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>编译opencore-amr for iOS8并支持bitcode</title>
    <url>/2017/01/05/build-opencore-amr/</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p><code>amr</code> 是一个很适合在线传输的音频格式。但悲摧的是<code>apple</code>早就不支持它了。原因不明。</p>
<p>另一层是微信也是使用的这种格式来录制音频。</p>
<p>不只<code>apple</code>不支持它，万能的<code>cocoapods</code>也没有支持的。只好自己动手了。</p>
<p>止于当前，我找到最合适的，就是<code>opencore-amr</code>库。这个库12年写就。这么多年也没见怎么更新。[捂脸]😂</p>
<p>找到了一个好心人写的支持<code>bitcode</code>和8.0的编译脚本</p>
<h1 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h1><p>github:<a class="link"   href="https://github.com/feuvan/opencore-amr-iOS" >opencore-amr-IOS<i class="fas fa-external-link-alt"></i></a></p>
<p>sourceforge:<a class="link"   href="https://sourceforge.net/projects/opencore-amr/files/opencore-amr/opencore-amr-0.1.3.tar.gz/download" >opencore-amr 0.1.3<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -xe</span><br><span class="line"></span><br><span class="line">VERSION=<span class="string">&quot;0.1.3&quot;</span></span><br><span class="line">SDKVERSION=<span class="string">&quot;8.4&quot;</span></span><br><span class="line">LIBSRCNAME=<span class="string">&quot;opencore-amr&quot;</span></span><br><span class="line"></span><br><span class="line">CURRENTPATH=`<span class="built_in">pwd</span>`</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="string">&quot;<span class="variable">$&#123;CURRENTPATH&#125;</span>/src&quot;</span></span><br><span class="line">tar zxvf <span class="variable">$&#123;LIBSRCNAME&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz -C <span class="string">&quot;<span class="variable">$&#123;CURRENTPATH&#125;</span>/src&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;CURRENTPATH&#125;</span>/src/<span class="variable">$&#123;LIBSRCNAME&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">DEVELOPER=`xcode-select -print-path`</span><br><span class="line">DEST=<span class="string">&quot;<span class="variable">$&#123;CURRENTPATH&#125;</span>/lib-ios&quot;</span></span><br><span class="line">mkdir -p <span class="string">&quot;<span class="variable">$&#123;DEST&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">ARCHS=<span class="string">&quot;armv7 armv7s arm64 i386 x86_64&quot;</span></span><br><span class="line"><span class="comment"># ARCHS=&quot;armv7&quot;</span></span><br><span class="line">LIBS=<span class="string">&quot;libopencore-amrnb.a libopencore-amrwb.a&quot;</span></span><br><span class="line"></span><br><span class="line">DEVELOPER=`xcode-select -print-path`</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> arch <span class="keyword">in</span> <span class="variable">$ARCHS</span>; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$arch</span> <span class="keyword">in</span></span><br><span class="line">arm*)</span><br><span class="line"></span><br><span class="line">IOSV=<span class="string">&quot;-miphoneos-version-min=7.0&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$arch</span> == <span class="string">&quot;arm64&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">IOSV=<span class="string">&quot;-miphoneos-version-min=7.0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Building for iOS <span class="variable">$arch</span> ****************&quot;</span></span><br><span class="line">SDKROOT=<span class="string">&quot;<span class="subst">$(xcrun --sdk iphoneos --show-sdk-path)</span>&quot;</span></span><br><span class="line">CC=<span class="string">&quot;<span class="subst">$(xcrun --sdk iphoneos -f clang)</span>&quot;</span></span><br><span class="line">CXX=<span class="string">&quot;<span class="subst">$(xcrun --sdk iphoneos -f clang++)</span>&quot;</span></span><br><span class="line">CPP=<span class="string">&quot;<span class="subst">$(xcrun -sdk iphonesimulator -f clang++)</span>&quot;</span></span><br><span class="line">CFLAGS=<span class="string">&quot;-isysroot <span class="variable">$SDKROOT</span> -arch <span class="variable">$arch</span> <span class="variable">$IOSV</span> -isystem <span class="variable">$SDKROOT</span>/usr/include -fembed-bitcode&quot;</span></span><br><span class="line">CXXFLAGS=<span class="variable">$CFLAGS</span></span><br><span class="line">CPPFLAGS=<span class="variable">$CFLAGS</span></span><br><span class="line"><span class="built_in">export</span> CC CXX CFLAGS CXXFLAGS CPPFLAGS</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--host=arm-apple-darwin \</span><br><span class="line">--prefix=<span class="variable">$DEST</span> \</span><br><span class="line">--disable-shared --enable-static</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">IOSV=<span class="string">&quot;-mios-simulator-version-min=7.0&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Building for iOS <span class="variable">$arch</span>*****************&quot;</span></span><br><span class="line"></span><br><span class="line">SDKROOT=`xcodebuild -version -sdk iphonesimulator Path`</span><br><span class="line">CC=<span class="string">&quot;<span class="subst">$(xcrun -sdk iphoneos -f clang)</span>&quot;</span></span><br><span class="line">CXX=<span class="string">&quot;<span class="subst">$(xcrun -sdk iphonesimulator -f clang++)</span>&quot;</span></span><br><span class="line">CPP=<span class="string">&quot;<span class="subst">$(xcrun -sdk iphonesimulator -f clang++)</span>&quot;</span></span><br><span class="line">CFLAGS=<span class="string">&quot;-isysroot <span class="variable">$SDKROOT</span> -arch <span class="variable">$arch</span> <span class="variable">$IOSV</span> -isystem <span class="variable">$SDKROOT</span>/usr/include -fembed-bitcode&quot;</span></span><br><span class="line">CXXFLAGS=<span class="variable">$CFLAGS</span></span><br><span class="line">CPPFLAGS=<span class="variable">$CFLAGS</span></span><br><span class="line"><span class="built_in">export</span> CC CXX CFLAGS CXXFLAGS CPPFLAGS</span><br><span class="line">./configure \</span><br><span class="line">--prefix=<span class="variable">$DEST</span> \</span><br><span class="line">--disable-shared</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line">make &gt; /dev/null</span><br><span class="line">make install</span><br><span class="line">make clean</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$LIBS</span>; <span class="keyword">do</span></span><br><span class="line">mv <span class="variable">$DEST</span>/lib/<span class="variable">$i</span> <span class="variable">$DEST</span>/lib/<span class="variable">$i</span>.<span class="variable">$arch</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$LIBS</span>; <span class="keyword">do</span></span><br><span class="line">input=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> arch <span class="keyword">in</span> <span class="variable">$ARCHS</span>; <span class="keyword">do</span></span><br><span class="line">input=<span class="string">&quot;<span class="variable">$input</span> <span class="variable">$DEST</span>/lib/<span class="variable">$i</span>.<span class="variable">$arch</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">lipo -create -output <span class="variable">$DEST</span>/lib/<span class="variable">$i</span> <span class="variable">$input</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="编译方式"><a href="#编译方式" class="headerlink" title="编译方式"></a>编译方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mkdir opencore-amr</span><br><span class="line">&gt; <span class="built_in">cd</span> opencore-amr</span><br><span class="line">&gt; <span class="comment">#把上方的脚本内容放到build.sh中。去下载0.1.3版的包，弄成下边的样子</span></span><br><span class="line">&gt; ls</span><br><span class="line">build.sh				opencore-amr-0.1.3.tar.gz</span><br><span class="line">&gt; bash build.sh</span><br><span class="line">&gt; .....</span><br><span class="line">&gt; <span class="comment">#完事后果子在：lib-ios文件夹中</span></span><br><span class="line">&gt; ls</span><br><span class="line">  build.sh			lib-ios				opencore-amr-0.1.3.tar.gz	src</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>xcode</tag>
        <tag>opencore-amr</tag>
        <tag>amr</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP Swoole 从入门到放弃</title>
    <url>/2017/06/20/byebye-swoole/</url>
    <content><![CDATA[<p>被Swoole文档上各种“高XX”说得口水流了一地。天真的我，决定花些时间，把自己项目的新业务迁移到swoole平台上来。</p>
<blockquote>
<p>今天谨以此文纪念我为了swoole而逝去的时光！</p>
</blockquote>
<p>以下是这段时间以来尝试过程中的各种痛：</p>
<hr>
<blockquote>
<p>高可用。可以通过给主进程发USR1信号来热更新代码，过程很优雅。我只要一个信号就全GET到了。</p>
</blockquote>
<ul>
<li>事实上。这有个蛋疼的前提：你必须先把server段的代码与worker段的业务代码分开。因为woker重启后，只能reload 启动后include进来的代码。这就操了大蛋了。</li>
</ul>
<hr>
<blockquote>
<p>高效编码。提供了协程，可以用同步的代码，得到异步的善果！nodejs还要async/await一下呢！</p>
</blockquote>
<ul>
<li>事实上。使用协程有两个条件！</li>
</ul>
<ol>
<li>只能在指定的地方使用，要是在别的地方使用，得用个回调，把代码包起来。与便与其它业务代码隔离开！</li>
<li>只能使用提供的几样东西。用开发者的话说：缓存只能使用redis，数据库只能用mysql。</li>
</ol>
<ul>
<li>这里还有更多其它蛋疼的事：</li>
</ul>
<ol>
<li>worker 中不能使用同步代码。因为它会阻塞整个完美的worker进程。顿时PHP的很多的第三方库成了废物。即便要用，也要丢到task进程中去。</li>
<li>task 进程有队列，但是，它只做了内部私有封装了的队列。还提出了若干条不清不楚的使用时的限制。如果任务失败，自己不收集，就无法重现。如果宕机，所有队列里的事，全了了账。队列里的事务也都成了悬案。这一点与laravel的队列比起来，可用性差得太TM远了！</li>
<li>逃不过的回调。其实PHP其它扩展也有异步的，譬如：ext-pgsql。可以用swoole的Event监听pgsql的socket可获得兼容的异步，但回调的问题就回来了。swoole重要的服务定义也是全程用回调的。包括worker/task/server/process这些对象生命周期。</li>
<li>不兼容。使用swoole的协程，其它不足不能用其它的异步PHP库做弥补，因为它们各自的event-loop不同。这一点怪不得swoole开发者。如果共用，不是通晓底层的大师级操刀，会出现各种稀奇古怪的问题。</li>
<li>功能弱。这一点主要表现在websocket Server这个对象上。swoole的websocket。声称自动的握手使用的是XX协议。但不支持使用websocket的内部的“协议”。如果带上协议名，就会拒绝。并且还有个让人蛋疼！如果自己实现握手协议，在很多版本中，它会自动地在返回的header中加入其它的头，导致被客户端拒绝！这一点开发者对此无能为力，因为swoole的response对象中的header，开发者只能加，不能改，不能删。它还不支持accept。什么样来路的请求都是直接到握手，如果要拒绝accept一些不合法的来源都不能轻易做到。</li>
<li>奇葩的异步http client。设计得还是满好的。但不知道什么原因，使用它请求腾讯的服务器，就是不稳定。40%会被拒。但如果使用nodejs 的 request。就能做到100%稳定！</li>
</ol>
<hr>
<blockquote>
<p>二进制分发。一次编译分发到各种平台。</p>
</blockquote>
<ul>
<li>一来，分发的需求不大。不同的环境需要不同的定制，服务器环境与开发环境的配置注定不能完全相同。</li>
<li>二来，编译起来就坑死人了。简单编译很多“高XX”的东西得不到。如果编译的系统有类库缺失，在configure中不会中止，只会在check的时候放个小小的’no’结尾。三个不同的系统平台上编译一下，包你眼花。PHPer对C的make了解并不深，很难编译出一个真正满意的结果。缺失类库的情况下编译出的so文件，放到PHP里后，一运行，PHP就会出一个<code>segmentfault</code>。并且有些第三方库要到放源码内部编译，有的是在外部单独编译安装。其中<code>jemalloc</code>库编译的时候还得加上专门为支持swoole而用的函数前缀。而文档对这里讲解，我就“呵呵”了。</li>
</ul>
<hr>
<blockquote>
<p>社区及支持</p>
</blockquote>
<ul>
<li>哎！今天我就是在github的issue里把swoole骂上天，恐怕傲慢的开发者也未必能看到我！虽然swoole项目天天有更新，但swoole开发者是在做他自己的事。我们swoole的用户如同苍蝇！</li>
</ul>
]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title>在FreeBSD12上编译PostgreSQL12</title>
    <url>/2019/10/23/build-postgresql12-on-freebsd12/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="在PostgreSQL12源码里运行-configure报："><a href="#在PostgreSQL12源码里运行-configure报：" class="headerlink" title="在PostgreSQL12源码里运行 ./configure报："></a>在<code>PostgreSQL12</code>源码里运行 <code>./configure</code>报：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">checking <span class="keyword">for</span> readline.h... no</span><br><span class="line">configure: error: readline header not found</span><br></pre></td></tr></table></figure>
<p>且<code>readline</code>库已经安装过了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pkg info readline</span></span><br><span class="line">readline-8.0.0</span><br><span class="line">Name           : readline</span><br><span class="line">Version        : 8.0.0</span><br></pre></td></tr></table></figure>
<p>原因是：<code>/usr/local/lib</code>和<code>/usr/local/include</code>不在<code>configure</code>脚本的搜索路径中。<br>可以通过<code>--with-includes</code>配置项加入进去就好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --with-includes=/usr/<span class="built_in">local</span>/include --with-libraries=/usr/<span class="built_in">local</span>/lib</span><br></pre></td></tr></table></figure>
<h3 id="llvm-config找不到"><a href="#llvm-config找不到" class="headerlink" title="llvm-config找不到"></a><code>llvm-config</code>找不到</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg install llvm90</span><br><span class="line"></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/llvm-config90 /usr/<span class="built_in">local</span>/bin/llvm-config</span><br></pre></td></tr></table></figure>
<h2 id="完整构建"><a href="#完整构建" class="headerlink" title="完整构建"></a>完整构建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --with-libraries=/usr/<span class="built_in">local</span>/lib --with-includes=/usr/<span class="built_in">local</span>/include --enable-thread-safety --disable-debug --with-openssl --with-llvm --prefix=/usr/<span class="built_in">local</span>/pg12 --localstatedir=/var --build=amd64-bluse-freebsd12.0 build_alias=amd64-bluse-freebsd12.0 --with-uuid=bsd --with-icu --enable-nls=<span class="string">&#x27;zh_CN&#x27;</span></span><br><span class="line">make world</span><br><span class="line">make install-world</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--enable-thread-safety</code> 线程安全</li>
<li><code>--disable-debug</code> 禁用debug，该是有助于提升生产时运行性能</li>
<li><code>--with-openssl</code> 支持加密传输</li>
<li><code>--with-llvm</code> 支持即时编译，使得在处理复杂任务时，性能有望再提升20%～30%</li>
<li><code>--build</code> 编译平台，格式：硬件平台-编译方-系统平台。如：“x86_64-myName-freebsd12.0”</li>
<li><code>build_alias</code> 编译平台别名</li>
<li><code>--with-uuid</code> 在<code>FreeBSD</code>上选择<code>bsd</code>应该是最合适的</li>
<li><code>--with-icu</code> 支持排序，依赖<code>pkgconf</code>包</li>
<li><code>--enable-nls</code> 软件本地化。可指定多种语言。依赖<code>GNU</code>的<code>gettext</code></li>
</ul>
]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>FreeBSD</tag>
      </tags>
  </entry>
  <entry>
    <title>daemontools系列小工具</title>
    <url>/2017/06/17/daemontools/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么要讲一个如此”古老”的守护工具？为什么不用supervisord？</p>
<p><code>supervisord</code> 有个问题疼死我了。一远程管理一下它守护下的进程，<a class="link"   href="https://github.com/Supervisor/supervisor/issues/807" >CPU就会100%<i class="fas fa-external-link-alt"></i></a>。这个问题年久失修。</p>
<p>它的supervisorctl里的指令，常reload一下会让所有的服务死了，自己也死了！也不重启，得手动重启。</p>
<p>更让人揪心的是，当业务负载繁重时，这个工具就成了”仙人掌”，碰不得，前段时间发现一次半夜里无端地持续了2个多小时把CPU提到了100%。</p>
<p>用了它可让阿里云破费了不少短信费。天天有警告！</p>
<p>不得已再花些时间学习了一下其它的守护工具了。这个daemontools偏老，看上去更稳妥。</p>
<p>以下实操基于FreeBSD11（Linux有systend，守护嘎嘎的！）</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a class="link"   href="http://cr.yp.to/daemontools.html" >Daemontools<i class="fas fa-external-link-alt"></i></a>是管理Unix服务的工具，它提供一组工具来管理一系列用户进程，当进程由于某些原因down掉之后，daemontools会自动重启进程</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>被管理的进程不能以daemon形式运行，例如nginx.conf 必须关闭daemon， daemon off;</li>
<li>不要在/var/service/建任何目录， /var/service/只存放一些symbol link</li>
<li>只需要完成安装 、 配置两步即可</li>
</ul>
<h1 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg install daemontools</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;svscan_enable=&quot;YES&quot;&#x27;</span> &gt; /etc/rc.conf</span><br><span class="line">service svscan start</span><br></pre></td></tr></table></figure>
<p>启动成功多出了2个进程：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root  7616   0.0  0.1   8344  1676  -  S    10:28     0:00.04 /usr/local/bin/svscan /var/service</span><br><span class="line">root  7617   0.0  0.1   6240  1616  -  I    10:28     0:00.00 /usr/local/bin/readproctitle service errors: ......................................................................</span><br></pre></td></tr></table></figure>
<p><code>svscan</code>启动后监视<code>/var/service</code>目录，当这里有服务的软连接时，svscan会为每个服务主恸一个<code>supervise</code>服务。<br><code>supervise</code> 执行服务目录下的<code>run</code>，如果服务目录下还有<code>down</code>文件存在，就不会自动启动，需人工手动启动此服务。</p>
<p><code>supervise</code>的状态信息以2进制的形式存放在服务目录的<code>supervise</code>下面，并且提供了下面的工具来操作：</p>
<ul>
<li>svstat： 读取状态信息</li>
<li>svc： 启动/停止/挂起等</li>
<li>svok： 检查是否运行成功</li>
<li>svscan：可靠的启动/var/service目录下的服务。如果某个服务加入后，没有启动，可以调用此命令，强制启动。</li>
</ul>
<h1 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h1><h2 id="普通添加"><a href="#普通添加" class="headerlink" title="普通添加"></a>普通添加</h2><p>先创建一个测试用的需要被守护的项目。放到：<code>/var/server/testprocess/</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@freebsd:/var/server/testprocess # ll</span><br><span class="line">total 12</span><br><span class="line">-rwxr-xr-x  1 root  wheel  122 Jun 17 10:30 main.py*</span><br><span class="line">-rwxr-xr-x  1 root  wheel  333 Jun 17 10:47 run*</span><br><span class="line">root@freebsd:/var/server/testprocess # cat main.py</span><br><span class="line">#!/usr/local/bin/python2</span><br><span class="line">import time</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    logging.warning(&quot;sleep 1 second&quot;)</span><br><span class="line"></span><br><span class="line">root@freebsd:/var/server/testprocess # cat run</span><br><span class="line">#!/bin/sh</span><br><span class="line">exec /usr/local/bin/python2 /var/server/testprocess/main.py &gt;&gt; /tmp/main.py.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>然后在<code>/var/service</code>目录下建立软链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@freebsd:/var/server/testprocess <span class="comment"># ln -s /var/server/testprocess /var/service/testprocess</span></span><br></pre></td></tr></table></figure>
<p>这个时候可以检查一下服务是否正在运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root  7618  0.0  0.1   6252  1632  -  I    10:28     0:00.00 supervise testprocess</span><br><span class="line">root  7747  0.0  0.4  39308  7416  -  S    10:48     0:00.72 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python2 &#x2F;var&#x2F;server&#x2F;testprocess&#x2F;main.py (python2.7)</span><br></pre></td></tr></table></figure>
<p>上面这种方式的坏处是必须以root用户运行，如果想以其他用户运行，则需要做如下改进，假设用户为bluse，id为1001：</p>
<h2 id="以指定用户身份运行"><a href="#以指定用户身份运行" class="headerlink" title="以指定用户身份运行"></a>以指定用户身份运行</h2><p>改进一下run的执行方式：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@freebsd:/var/server/testprocess # cat run</span><br><span class="line">#!/bin/sh</span><br><span class="line">who=`id -u`</span><br><span class="line">if [ $who -eq 0 ]; then</span><br><span class="line">    exec /usr/local/bin/setuidgid bluse /usr/local/bin/python2 /var/server/testprocess/main.py &gt;&gt; /tmp/main.py.log 2&gt;&amp;1</span><br><span class="line">elif [ $who -eq 1001 ]; then</span><br><span class="line">    exec /usr/local/bin/python2 /var/server/service/testprocess/main.py &gt;&gt; /tmp/main.py.log 2&gt;&amp;1</span><br><span class="line">else</span><br><span class="line">    echo &quot;neither root or bluse&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>就可以了</p>
<h1 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h1><p>使用svstat来查看服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@freebsd:&#x2F;var&#x2F;server&#x2F;testprocess # svstat &#x2F;var&#x2F;server&#x2F;testprocess&#x2F;</span><br><span class="line">&#x2F;var&#x2F;server&#x2F;testprocess&#x2F;: up (pid 7747) 2680 seconds</span><br></pre></td></tr></table></figure>
<p>使用svc来管理服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       svc - controls services monitored by supervise(8).</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       svc [ -udopchaitkx ] services</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       services consists of any number of arguments, each argument naming a</span><br><span class="line">       directory used by supervise(8).</span><br><span class="line"></span><br><span class="line">       svc applies all the options to each service in turn.</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line">       -u     Up. If the service is not running, start it. If the service</span><br><span class="line">              stops, restart it.</span><br><span class="line"></span><br><span class="line">       -d     Down. If the service is running, send it a TERM signal and then</span><br><span class="line">              a CONT signal. After it stops, do not restart it.</span><br><span class="line"></span><br><span class="line">       -o     Once. If the service is not running, start it. Do not restart it</span><br><span class="line">              if it stops.</span><br><span class="line"></span><br><span class="line">       -p     Pause. Send the service a STOP signal.</span><br><span class="line"></span><br><span class="line">       -c     Continue. Send the service a CONT signal.</span><br><span class="line"></span><br><span class="line">       -h     Hangup. Send the service a HUP signal.</span><br><span class="line"></span><br><span class="line">       -a     Alarm. Send the service an ALRM signal.</span><br><span class="line"></span><br><span class="line">       -i     Interrupt. Send the service an INT signal.</span><br><span class="line"></span><br><span class="line">       -t     Terminate. Send the service a TERM signal.</span><br><span class="line"></span><br><span class="line">       -k     Kill. Send the service a KILL signal.</span><br><span class="line"></span><br><span class="line">       -x     Exit.  supervise(8) will exit as soon as the service is down. If</span><br><span class="line">              you use this option on a stable system, you&#39;re doing something</span><br><span class="line">              wrong; supervise(8) is designed to run forever.</span><br></pre></td></tr></table></figure>
<h1 id="daemontools-中的其它工具"><a href="#daemontools-中的其它工具" class="headerlink" title="daemontools 中的其它工具"></a>daemontools 中的其它工具</h1><p>log工具：</p>
<ul>
<li>The readproctitle program</li>
<li>The multilog program</li>
<li>The tai64n program</li>
<li>The tai64nlocal program</li>
</ul>
<p>环境工具：</p>
<ul>
<li>The setuidgid program</li>
<li>The envuidgid program</li>
<li>The envdir program</li>
<li>The softlimit program</li>
<li>The setlock program</li>
</ul>
]]></content>
      <tags>
        <tag>FreeBSD</tag>
        <tag>daemontool</tag>
        <tag>supervisord</tag>
      </tags>
  </entry>
  <entry>
    <title>swift3升级后居然不做后向兼容</title>
    <url>/2017/01/02/damned-xcode/</url>
    <content><![CDATA[<p>坑死爹了！<code>apple</code>这次升级从系统OS到开发工具，没一个不是到处坑人。</p>
<p>mac os 10，升级后，一插android手机就死机！windows蓝屏，它白屏！</p>
<p>xcode升级至8后，上来就要给我的项目转码！想着我大小也是付费用户。每年都交着会费呢！应该给我的待遇不会差的。</p>
<p>没成想，点完OK后。成百上千个错！错误数量999+！它居然不后向兼容！说好的只是语法变动点的嘛！</p>
<p>我自己的项目代码就算了，当时alamofire，SwiftyJSON 等等，我有数十个第三方cocoapod库，没一个支持到swift3的，当时就慌了神了。</p>
<p>想着我还有SVN。xcode这货对SVN的支持是业余级的。自带的提交麻烦就算了。版本还是老的。搞得我提交次数又少。</p>
<p>现在网上翻了翻，好多人为了稳定还在用着xcode7呢！还是我too young!too simple!</p>
<p>以此纪念我上过apple的当！</p>
]]></content>
      <tags>
        <tag>xcode</tag>
        <tag>swift3</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg视频裁剪</title>
    <url>/2021/02/01/ffmpeg-resize/</url>
    <content><![CDATA[<p>视频裁剪就是选中你想要的矩形区域并只输出这个区域，去污不残留。裁剪通常和大小调整，填充和其他操作一起使用。</p>
<h1 id="基本裁切内容"><a href="#基本裁切内容" class="headerlink" title="基本裁切内容"></a>基本裁切内容</h1><p>老版本的FFmpeg有<code>cropbottom</code>、<code>cropleft</code>、<code>cropright</code>、<code>croptop</code>几个指令，但是现在过时了。裁剪操作现在使用下表描述的<code>crop</code>滤镜。</p>
<p><img src="https://user-images.githubusercontent.com/1764005/106429770-d9b79280-64a5-11eb-9531-c3673b9399bf.png" alt="image"></p>
<p><code>ow</code>的值能够通过<code>oh</code>的值推导得出，反之亦然。但是不能通过<code>x</code>和y推导得出，因为它们是在<code>ow</code>和<code>oh</code>之后进行求值的。另外<code>x</code>能够通过<code>y</code>推导得出，反之亦然。</p>
<p>好懵逼。先看人家举的栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input -vf crop=iw/3:ih:0:0 output</span><br><span class="line">ffmpeg -i input -vf crop=iw/3:ih:iw/3:0 output</span><br><span class="line">ffmpeg -i input -vf crop=iw/3:ih:iw/3*2:0 output</span><br></pre></td></tr></table></figure>
<p>结果还是没明白人家什么意思。再看个图：<br><img src="https://user-images.githubusercontent.com/1764005/106429885-09669a80-64a6-11eb-9c9c-cc4846b40487.png" alt="image"></p>
<h1 id="中心裁剪"><a href="#中心裁剪" class="headerlink" title="中心裁剪"></a>中心裁剪</h1><p>当我们进行中心裁剪操作时，可以跳过<code>crop</code>滤镜<code>x</code>和<code>y</code>参数的输入。默认<code>x</code>和<code>y</code>的值分别是：<code>x_default = ( input width - output width)/2，y_default = ( input height - output height)/2</code><br>这意味着中心裁剪时默认值是自动设置的。那么裁剪中心区域的语法是：<code>ffmpeg -i input_file -vf crop=w:h output_file</code><br>例如<code>ffmpeg -i input.mpg -vf crop=iw/2:ih/2 output.mp4</code>表示以中心裁剪的方式裁出宽高为原视频一半的视频。</p>
]]></content>
      <tags>
        <tag>FFmpeg</tag>
        <tag>视频剪裁</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeBSD 11 磁盘空间扩容</title>
    <url>/2018/06/16/freebsd-disk-resize/</url>
    <content><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>阿里云买了个60G的系统盘ECS。进去一看只有20G！<br>原因是：它刷镜像时，只刷了前边的20G。后边的40G，就成了空白。结果交到我手上，就成了个半成品。<br>只得自己给它扩容</p>
<p>初始状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@log:~ # df -h</span><br><span class="line">Filesystem                     Size    Used   Avail Capacity  Mounted on</span><br><span class="line">/dev/ufsid/59a7effe7885633c     19G    4.1G     14G    23%    /</span><br><span class="line">devfs                          1.0K    1.0K      0B   100%    /dev</span><br></pre></td></tr></table></figure>
<h3 id="第一步：查看"><a href="#第一步：查看" class="headerlink" title="第一步：查看"></a>第一步：查看</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@log:~ # gpart show</span><br><span class="line">=&gt;       63  125829057  vtbd0  MBR  (60G)</span><br><span class="line">         63          1         - free -  (512B)</span><br><span class="line">         64   41942975      1  freebsd  [active]  (20G)</span><br><span class="line">   41943039   83886081         - free -  (40G)</span><br></pre></td></tr></table></figure>
<p>的确有40G的空白</p>
<h3 id="第二步：重置大小"><a href="#第二步：重置大小" class="headerlink" title="第二步：重置大小"></a>第二步：重置大小</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@log:~ # gpart resize -i 1 -a 4k -s 59G vtbd0</span><br><span class="line">vtbd0s1 resized</span><br></pre></td></tr></table></figure>
<p><code>-i 1</code> 这里的<code>1</code>是抄写 <code>gpart show</code>中<code>vtbd0</code>一栏下当前正使用的磁盘的编号<br><code>-s 59G</code> 为什么要丢掉一个G？因为交换分区需要空间。</p>
<h3 id="第三步：执行配置"><a href="#第三步：执行配置" class="headerlink" title="第三步：执行配置"></a>第三步：执行配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@log:~ # service growfs onestart</span><br><span class="line">Growing root partition to fill device</span><br><span class="line">vtbd0s1 resized</span><br><span class="line">super-block backups (for fsck_ffs -b #) at:</span><br><span class="line"> 42314112, 43596352, 44878592, 46160832, 47443072, 48725312, 50007552, 51289792, 52572032, 53854272, 55136512, 56418752, 57700992, 58983232, 60265472, 61547712, 62829952,</span><br><span class="line"> 64112192, 65394432, 66676672, 67958912, 69241152, 70523392, 71805632, 73087872, 74370112, 75652352, 76934592, 78216832, 79499072, 80781312, 82063552, 83345792, 84628032,</span><br><span class="line"> 85910272, 87192512, 88474752, 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432, 98732672, 100014912, 101297152, 102579392, 103861632, 105143872, 106426112,</span><br><span class="line"> 107708352, 108990592, 110272832, 111555072, 112837312, 114119552, 115401792, 116684032, 117966272, 119248512, 120530752, 121812992, 123095232, 124377472, 125659712</span><br></pre></td></tr></table></figure>
<h3 id="完成！并检查"><a href="#完成！并检查" class="headerlink" title="完成！并检查"></a>完成！并检查</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@log:~ # df -h</span><br><span class="line">Filesystem                     Size    Used   Avail Capacity  Mounted on</span><br><span class="line">/dev/ufsid/59a7effe7885633c     58G    4.2G     49G     8%    /</span><br><span class="line">devfs                          1.0K    1.0K      0B   100%    /dev</span><br><span class="line">root@log:~ # gpart show</span><br><span class="line">=&gt;       63  125829057  vtbd0  MBR  (60G)</span><br><span class="line">         63          1         - free -  (512B)</span><br><span class="line">         64  125829056      1  freebsd  [active]  (60G)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>FreeBSD</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeBSD上使用tunnelbroker隧道支持ipv6</title>
    <url>/2017/03/19/freebsd-nginx-ipv6-with-tunnelbroker/</url>
    <content><![CDATA[<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>IOS被拒，原因又是<code>IPV6 only</code>网络下访问异常！</p>
<p>于是开始自检！</p>
<p>先检查了代码，没有使用只能用于ipv4的代码。</p>
<p>接口中也没有使用ipv4静态地址的请求。</p>
<p>那就是网络问题了！</p>
<p>先模拟了一下<code>ipv6</code>网络。成功配置了mac pro共享网络。访问了一下！没毛病！</p>
<p>那就是<code>IPV6 only</code>网络至ipv4，且走国际线路，这个有些特别了！<br>找了一下发现不少人吐嘈这个事，文章中甚至扬言要投靠<code>Android</code>^_^。<br>且有公司已经把优化国内IPV4至苹果公司的ipv6-only的网络做成服务，当生意做了。</p>
<p>这个问题自己解决就是给自己的服务器上加一个ipv6地址，就OK啦！<br>但现实太骨感，阿里云没有ipv6。只好通过其它途径了。比较合适的方案就是使用<a class="link"   href="https://tunnelbroker.net/" >tunnelbroker<i class="fas fa-external-link-alt"></i></a>提供的ipv6隧道了。</p>
<h1 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h1><ul>
<li>注册账号</li>
<li>验证邮箱<br>完成后，登录进去，在左侧的<code>User Functions</code>下<code>Create Regular Tunnel</code>创建一个常规的就好。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>创建完通道后，在<code>Tunnel Details</code>下有个<code>Example Configurations</code>标签，这里能按你的系统生成配置指令。<br>进去选择<code>Freebsd &gt; 4.4</code>，得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ifconfig gif0 create</span><br><span class="line">ifconfig gif0 tunnel [我的IP] 209.51.161.14  #我服务器的IP 帮我转发的ipv4IP</span><br><span class="line">ifconfig gif0 inet6 2001:470:1f06:1458::2 2001:470:1f06:1458::1 prefixlen 128       # 出隧道后，我在公网上的ipv6地址 隧道方的服务ipv6地址</span><br><span class="line">route -n add -inet6 default 2001:470:1f06:1458::1</span><br><span class="line">ifconfig gif0 up</span><br></pre></td></tr></table></figure>
<p>进去执行掉<br>执行完后，<code>ifconfig</code>里就会多出来一个gif0设备。</p>
<p>FreeBSD的/etc/rc.conf增加配置，把禁止ipv6的项删去。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># IPv6 Tunnel Client</span><br><span class="line">ipv6_enable=&quot;YES&quot;</span><br><span class="line">gif_interfaces=&quot;gif0&quot;</span><br><span class="line">gifconfig_gif0=&quot;[我的IP] 209.51.161.14&quot;</span><br><span class="line">ipv6_ifconfig_gif0=&quot;2001:470:1f06:1458::2 2001:470:1f06:1458::1 prefixlen 128&quot;</span><br><span class="line">ipv6_defaultrouter=&quot;2001:470:1f06:1458::1&quot;</span><br><span class="line"> </span><br><span class="line"># IPv6 Gateway</span><br><span class="line">ipv6_config_nfe0=&quot;2001:470:1f07:1458::1 prefixlen 64&quot;   #这个是路由地址：在‘Tunnel Details’ 里，是‘Routed IPv6 Prefixes’下的‘Routed /64’项。</span><br><span class="line">ipv6_gateway_enable=&quot;YES&quot;</span><br><span class="line">rtadvd_enable=&quot;YES&quot;</span><br><span class="line">rtadvd_interfaces=&quot;nfe0&quot;</span><br></pre></td></tr></table></figure>
<p>这个需要rtadvd服务，<code>service rtadvd start</code>。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>FreeBSD处理ipv4与v6是两条不同的道。<br>所以在<code>nginx</code>里，要加上ipv6的监听，类似：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">listen 443 ssl;</span><br><span class="line">listen [::]:443 ssl;</span><br></pre></td></tr></table></figure>
<p>再<code>sysctl net.inet6.ip6.forwarding</code>一下，看看是否支持转发。<br>如果是0。就得放开！执行：<code>sysctl -w net.inet6.ip6.forwarding=1</code>。</p>
<h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h2><p>进入DNSPOD给域名下加一条<code>AAAA</code>记录。地址用<code>2001:470:1f06:1458::2</code>。</p>
<h1 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h1><p>没有ipv6-only环境，怎么判断这一切生效了呢？只需打开浏览器访问：<a href="http://www.wangjunfeng.com.cn.ipv4.sixxs.org/"><code>http://www.wangjunfeng.com.cn.ipv4.sixxs.org</code></a>。<br>这里<code>www.wangjunfeng.com.cn</code>就是要支持的网址了。如果正常打开。就OK了！</p>
]]></content>
      <tags>
        <tag>FreeBSD</tag>
        <tag>nginx</tag>
        <tag>ipv6</tag>
        <tag>tunnelbroker</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeBSD 的日常</title>
    <url>/2017/07/22/freebsd/</url>
    <content><![CDATA[<h1 id="查看当前内核，编译时的参数"><a href="#查看当前内核，编译时的参数" class="headerlink" title="查看当前内核，编译时的参数"></a>查看当前内核，编译时的参数</h1><p><code>sysctl kern.conftxt</code></p>
<h1 id="配置并编译新内核"><a href="#配置并编译新内核" class="headerlink" title="配置并编译新内核"></a>配置并编译新内核</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/sys/amd64/conf/</span><br><span class="line">ee GENERIC</span><br><span class="line">config GENERIC</span><br><span class="line"><span class="built_in">cd</span> ../compile/GENERIC/</span><br><span class="line">make cleandepend &amp;&amp; make depend</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h1 id="从低版本内核升级至高版本"><a href="#从低版本内核升级至高版本" class="headerlink" title="从低版本内核升级至高版本"></a>从低版本内核升级至高版本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv UNAME_r <span class="string">&quot;10.3-RELEASE&quot;</span></span><br><span class="line">freebsd-update -r 11.0-RELEASE upgrade</span><br><span class="line">freebsd-update insatll</span><br><span class="line">reboot</span><br><span class="line">freebsd-update insatll</span><br></pre></td></tr></table></figure>
<ul>
<li>注册不能跨大版本。如：从10.1 -&gt; 11.0 中间要经过10.3。 10.1 -&gt; 10.3 -&gt; 11.0</li>
<li>如果有定义自己内核，需先升级，再编译自己的配置。</li>
</ul>
<h1 id="给内核打补丁"><a href="#给内核打补丁" class="headerlink" title="给内核打补丁"></a>给内核打补丁</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">freebsd-update fetch</span><br><span class="line">freebsd-update install</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>FreeBSD</tag>
      </tags>
  </entry>
  <entry>
    <title>gin上同时实现websocket</title>
    <url>/2019/07/30/gin-with-websocket/</url>
    <content><![CDATA[<h1 id="一个在Gin框架上实现websocket的样例"><a href="#一个在Gin框架上实现websocket的样例" class="headerlink" title="一个在Gin框架上实现websocket的样例"></a>一个在Gin框架上实现websocket的样例</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gorilla/websocket&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	upgrader = websocket.Upgrader&#123;</span><br><span class="line">		ReadBufferSize:   <span class="number">1024</span>,</span><br><span class="line">		WriteBufferSize:  <span class="number">1024</span>,</span><br><span class="line">		CheckOrigin:      <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;,</span><br><span class="line">		HandshakeTimeout: time.Duration(time.Second * <span class="number">5</span>),</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleWebsocket</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	conn, err := upgrader.Upgrade(c.Writer, c.Request, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;cant upgrade connection:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		msgType, msgData, err := conn.ReadMessage()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;cant read message:&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *websocket.CloseError:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Skip binary messages</span></span><br><span class="line">		<span class="keyword">if</span> msgType != websocket.TextMessage &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">&quot;incoming message: %s\n&quot;</span>, msgData)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	router.GET(<span class="string">&quot;/websocket&quot;</span>, handleWebsocket)</span><br><span class="line">	router.Run(<span class="string">&quot;:5000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备自：<a class="link"   href="https://github.com/gin-gonic/gin/issues/1305" >https://github.com/gin-gonic/gin/issues/1305<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>gin</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>golang udp 服务的坑</title>
    <url>/2020/06/29/golang-udp-server/</url>
    <content><![CDATA[<p>golang udp 服务端演示级的写法一般是：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">   conn, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;Port: <span class="number">8866</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;Udp Service listen report udp fail:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">4</span>)</span><br><span class="line">	n, remoteAddr, err := conn.ReadFromUDP(data)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// ... 做点什么</span></span><br><span class="line">           conn.WriteToUDP(data[:n], remoteAddr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码作为教学或演示是没有问题的。但应用于生产时，处在在一个频繁收发报文的中心服务器上，这里就有两个问题了：</p>
<ul>
<li>在<code>for</code>循环中不断申请变量<code>data</code>并<code>make</code>。会产生大量内存消耗。引起频繁GC。</li>
<li>收到数据后处理不应该在<code>for</code>循环内部。因为如果数据处理时间过长，就会拥塞。拥塞期间若底层缓冲区满了，说不定会丢包。</li>
</ul>
<p>那么V2版写法来了：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">   conn, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;Port: <span class="number">8866</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;Udp Service listen report udp fail:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">   data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	n, remoteAddr, err := conn.ReadFromUDP(data)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">               <span class="comment">// ... 拿 data[:n]做点什么</span></span><br><span class="line">               conn.WriteToUDP(data[:n], remoteAddr)</span><br><span class="line">           &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>V2版看上去完美！其实运行结果会完全出人意料！</p>
<p>因为每次<code>for</code>循环没有将<code>data</code>置0，当传输的是二进制时，会导致上次Read的结果干扰下次Read的结果。导致对数据 <code>Unmarshal</code>时随机出错！如果不借助<code>tcpdump</code>抓包做位级比对！这会变成一个玄学问题！</p>
<p>ok！再来V3！</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">   conn, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;Port: <span class="number">8866</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;Udp Service listen report udp fail:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">   <span class="keyword">var</span> data []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">       data = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">4</span>)</span><br><span class="line">	n, remoteAddr, err := conn.ReadFromUDP(data)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">               <span class="comment">// ... 拿 data[:n]做点什么</span></span><br><span class="line">               conn.WriteToUDP(data[:n], remoteAddr)</span><br><span class="line">           &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>V3版成功解决了干扰！</p>
<p>但又来了新问题。就是：在协程中处理数据<code>data[:n]</code>时总是所有位是<code>0</code>的<code>n</code>位长的数组。辣么，数据呢？</p>
<p>当然是协程内引用<code>data</code>导致的。因为在协程创建完成，开始执行前，<code>for</code>已经进入下一个循环并在<code>Read</code>处等待了。此时的<code>data</code>经过<code>make</code>已经重置数据了。</p>
<blockquote>
<p>这里要介绍一个<code>golang</code>的基础功能<code>copy</code></p>
<blockquote>
<p><code>golang</code> 为了避免每一层的处理数据都要在内存里建立相同数据的副本。采用了引用的方式传递。也就是<code>slice</code>的存在的意义！它大量节约了内存！天才般的设计！<br><br>这里<code>conn.ReadFromUDP(data)</code>后<code>data</code>里放的其实是底层缓冲区内的数据引用。操作<code>data</code>实际上是在操作底层缓冲区。<br><br>所以我们在操作<code>data</code>前一定要先将<code>data</code>里的数据读入新的变量里，实现<code>私有化</code>，再交给协程处理。否则在协程未启动完成前，<code>data</code>里的数据可能因为进入新的循环，而被刷新！<br><br>不幸的是，简单的<code>=</code>是不能将<code>data</code> <code>私有化</code>的。只能<code>make</code>一个空白的<code>slice</code>，再将<code>data</code>逐个复制进来。这个操作<code>golang</code>已为我们封装好了一个函数，它就是：<code>copy</code></p>
</blockquote>
</blockquote>
<p>ok！再来V4！</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">conn, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;Port: <span class="number">8866</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;Udp Service listen report udp fail:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">4</span>)</span><br><span class="line"><span class="keyword">var</span> raw []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	n, remoteAddr, err := conn.ReadFromUDP(data)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		raw = <span class="built_in">make</span>([]<span class="keyword">byte</span>,n)</span><br><span class="line">		<span class="built_in">copy</span>(raw,data[:n])</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="comment">// ... 拿 raw 做点什么</span></span><br><span class="line">			conn.WriteToUDP(raw, remoteAddr)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok! 运行起来几乎没啥问题。</p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables详细教程：基础、架构、清空规则、追加规则、应用实例</title>
    <url>/2019/12/14/iptables/</url>
    <content><![CDATA[<p>iptables防火墙可以用于创建过滤(filter)与NAT规则。所有Linux发行版都能使用iptables，因此理解如何配置iptables将会帮助你更有效地管理Linux防火墙。如果你是第一次接触iptables，你会觉得它很复杂，但是一旦你理解iptables的工作原理，你会发现其实它很简单。</p>
<p>首先介绍iptables的结构：iptables -&gt; Tables -&gt; Chains -&gt; Rules. 简单地讲，tables由chains组成，而chains又由rules组成。如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/1764005/70845966-94926480-1e8f-11ea-8c62-38010afa3146.png" alt="image"><br>图: IPTables Table, Chain, and Rule Structure</p>
<h1 id="iptables的表与链"><a href="#iptables的表与链" class="headerlink" title="iptables的表与链"></a>iptables的表与链</h1><p>iptables具有Filter, NAT, Mangle, Raw四种内建表：</p>
<h2 id="Filter表"><a href="#Filter表" class="headerlink" title="Filter表"></a>Filter表</h2><p>Filter表示iptables的默认表，因此如果你没有自定义表，那么就默认使用filter表，它具有以下三种内建链：</p>
<ul>
<li><strong>INPUT链</strong> – 处理来自外部的数据。</li>
<li><strong>OUTPUT链</strong> – 处理向外发送的数据。</li>
<li><strong>FORWARD链</strong> – 将数据转发到本机的其他网卡设备上。</li>
</ul>
<h2 id="NAT表"><a href="#NAT表" class="headerlink" title="NAT表"></a>NAT表</h2><p>NAT表有三种内建链：</p>
<ul>
<li><strong>PREROUTING链</strong> – 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址（destination ip address），通常用于DNAT(destination NAT)。</li>
<li><strong>POSTROUTING链</strong> – 处理即将离开本机的数据包。它会转换数据包中的源IP地址（source ip address），通常用于SNAT（source NAT）。</li>
<li><strong>OUTPUT链</strong> – 处理本机产生的数据包。</li>
</ul>
<h2 id="Mangle表"><a href="#Mangle表" class="headerlink" title="Mangle表"></a>Mangle表</h2><p>Mangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。Mangle表具有5个内建链：</p>
<ul>
<li>PREROUTING</li>
<li>OUTPUT</li>
<li>FORWARD</li>
<li>INPUT</li>
<li>POSTROUTING</li>
</ul>
<h2 id="Raw表"><a href="#Raw表" class="headerlink" title="Raw表"></a>Raw表</h2><p>Raw表用于处理异常，它具有2个内建链：</p>
<p>PREROUTING chain<br>OUTPUT chain</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>下图展示了iptables的三个内建表：</p>
<p><img src="https://user-images.githubusercontent.com/1764005/70846052-68c3ae80-1e90-11ea-83db-51e4b4e01987.png" alt="图: IPTables 内建表"><br>图: IPTables 内建表</p>
<h1 id="IPTABLES-规则-Rules"><a href="#IPTABLES-规则-Rules" class="headerlink" title="IPTABLES 规则(Rules)"></a>IPTABLES 规则(Rules)</h1><p>牢记以下三点式理解iptables规则的关键：</p>
<ul>
<li>Rules包括一个条件和一个目标(target)</li>
<li>如果满足条件，就执行目标(target)中的规则或者特定值。</li>
<li>如果不满足条件，就判断下一条Rules。</li>
</ul>
<h2 id="目标值（Target-Values）"><a href="#目标值（Target-Values）" class="headerlink" title="目标值（Target Values）"></a>目标值（Target Values）</h2><p>下面是你可以在target里指定的特殊值：</p>
<ul>
<li>ACCEPT – 允许防火墙接收数据包</li>
<li>DROP – 防火墙丢弃包</li>
<li>QUEUE – 防火墙将数据包移交到用户空间</li>
<li>RETURN – 防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain)中。<br>如果你执行<code>iptables --list</code>你将看到防火墙上的可用规则。下例说明当前系统没有定义防火墙，你可以看到，它显示了默认的filter表，以及表内默认的input链, forward链, output链。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -t filter --list</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br></pre></td></tr></table></figure>
查看mangle表：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -t mangle --list</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
查看NAT表：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -t nat --list</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
查看RAW表：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -t raw --list</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
注意：如果不指定<code>-t</code>选项，就只会显示默认的<code>filter</code>表。因此，以下两种命令形式是一个意思：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -t filter --list</span></span><br><span class="line">(or)</span><br><span class="line"><span class="comment"># iptables --list</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
以下例子表明在filter表的input链, forward链, output链中存在规则：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables --list</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">1    RH-Firewall-1-INPUT  all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">1    RH-Firewall-1-INPUT  all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain RH-Firewall-1-INPUT (2 references)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">1    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">2    ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           icmp <span class="built_in">type</span> 255</span><br><span class="line">3    ACCEPT     esp  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">4    ACCEPT     ah   --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">5    ACCEPT     udp  --  0.0.0.0/0            224.0.0.251         udp dpt:5353</span><br><span class="line">6    ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0           udp dpt:631</span><br><span class="line">7    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:631</span><br><span class="line">8    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED</span><br><span class="line">9    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22</span><br><span class="line">10   REJECT     all  --  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
以上输出包含下列字段：</li>
</ul>
<p><strong>num</strong> – 指定链中的规则编号<br><strong>target</strong> – 前面提到的target的特殊值<br><strong>prot</strong> – 协议：tcp, udp, icmp等<br><strong>source</strong> – 数据包的源IP地址<br><strong>destination</strong> – 数据包的目标IP地址</p>
<h1 id="清空所有iptables规则"><a href="#清空所有iptables规则" class="headerlink" title="清空所有iptables规则"></a>清空所有iptables规则</h1><p>在配置<code>iptables</code>之前，你通常需要用<code>iptables --list</code>命令或者<code>iptables-save</code>命令查看有无现存规则，因为有时需要删除现有的<code>iptables</code>规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables --flush</span><br><span class="line">或者</span><br><span class="line">iptables -F</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两条命令是等效的。但是并非执行后就万事大吉了。你仍然需要检查规则是不是真的清空了，因为有的linux发行版上这个命令不会清除NAT表中的规则，此时只能手动清除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t NAT -F</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="永久生效"><a href="#永久生效" class="headerlink" title="永久生效"></a>永久生效</h1><p>当你删除、添加规则后，这些更改并不能永久生效，这些规则很有可能在系统重启后恢复原样。为了让配置永久生效，根据平台的不同，具体操作也不同。下面进行简单介绍：</p>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>首先，保存现有的规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /etc/iptables.rules</span><br></pre></td></tr></table></figure>
<p>然后新建一个bash脚本，并保存到<code>/etc/network/if-pre-up.d/</code>目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">iptables-restore &lt; /etc/iptables.rules</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，每次系统重启后iptables规则都会被自动加载。<br>注意：不要尝试在<code>.bashrc</code>或者<code>.profile</code>中执行以上命令，因为用户通常不是root，而且这只能在登录时加载iptables规则。</p>
<h1 id="追加iptables规则"><a href="#追加iptables规则" class="headerlink" title="追加iptables规则"></a>追加<code>iptables</code>规则</h1><p>可以使用<code>iptables -A</code>命令追加新规则，其中<code>-A</code>表示<code>Append</code>。因此，新的规则将追加到链尾。<br>一般而言，最后一条规则用于丢弃(DROP)所有数据包。如果你已经有这样的规则了，并且使用<code>-A</code>参数添加新规则，那么就是无用功。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A chain firewall-rule</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-A chain</code> – 指定要追加规则的链</li>
<li><code>firewall-rule</code> – 具体的规则参数</li>
</ul>
<h2 id="描述规则的基本参数"><a href="#描述规则的基本参数" class="headerlink" title="描述规则的基本参数"></a>描述规则的基本参数</h2><p>以下这些规则参数用于描述数据包的协议、源地址、目的地址、允许经过的网络接口，以及如何处理这些数据包。这些描述是对规则的基本描述。</p>
<h3 id="p-协议（protocol）"><a href="#p-协议（protocol）" class="headerlink" title="-p 协议（protocol）"></a>-p 协议（protocol）</h3><ul>
<li>指定规则的协议，如<code>tcp</code>, <code>udp</code>, <code>icmp</code>等，可以使用<code>all</code>来指定所有协议。</li>
<li>如果不指定<code>-p</code>参数，则默认是<code>all</code>值。这并不明智，请总是明确指定协议名称。</li>
<li>可以使用协议名(如tcp)，或者是协议值（比如6代表tcp）来指定协议。映射关系请查看<code>/etc/protocols</code></li>
<li>还可以使用<code>–protocol</code>参数代替<code>-p</code>参数</li>
</ul>
<h3 id="s-源地址（source）"><a href="#s-源地址（source）" class="headerlink" title="-s 源地址（source）"></a>-s 源地址（source）</h3><ul>
<li>指定数据包的源地址</li>
<li>参数可以使IP地址、网络地址、主机名</li>
<li>例如：-s 192.168.1.101指定IP地址</li>
<li>例如：-s 192.168.1.10/24指定网络地址</li>
<li>如果不指定-s参数，就代表所有地址</li>
<li>还可以使用<code>–src</code>或者<code>–source</code></li>
</ul>
<h3 id="d-目的地址（destination）"><a href="#d-目的地址（destination）" class="headerlink" title="-d 目的地址（destination）"></a>-d 目的地址（destination）</h3><ul>
<li>指定目的地址</li>
<li>参数和<code>-s</code>相同</li>
<li>还可以使用<code>–dst</code>或者<code>–destination</code></li>
</ul>
<h3 id="j-执行目标（jump-to-target）"><a href="#j-执行目标（jump-to-target）" class="headerlink" title="-j 执行目标（jump to target）"></a>-j 执行目标（jump to target）</h3><ul>
<li><code>-j</code>代表”jump to target”</li>
<li><code>-j</code>指定了当与规则(Rule)匹配时如何处理数据包</li>
<li>可能的值是<code>ACCEPT</code>, <code>DROP</code>, <code>QUEUE</code>, <code>RETURN</code></li>
<li>还可以指定其他链（Chain）作为目标</li>
</ul>
<h3 id="i-输入接口（input-interface）"><a href="#i-输入接口（input-interface）" class="headerlink" title="-i 输入接口（input interface）"></a>-i 输入接口（input interface）</h3><ul>
<li><code>-i</code>代表输入接口(input interface)</li>
<li><code>-i</code>指定了要处理来自哪个接口的数据包</li>
<li>这些数据包即将进入<code>INPUT</code>, <code>FORWARD</code>, <code>PREROUTE链</code></li>
<li>例如：<code>-i eth0</code>指定了要处理经由eth0进入的数据包</li>
<li>如果不指定<code>-i</code>参数，那么将处理进入所有接口的数据包</li>
<li>如果出现! <code>-i eth0</code>，那么将处理所有经由eth0以外的接口进入的数据包</li>
<li>如果出现<code>-i eth+</code>，那么将处理所有经由eth开头的接口进入的数据包</li>
<li>还可以使用<code>–in-interface</code>参数</li>
</ul>
<h3 id="o-输出（out-interface）"><a href="#o-输出（out-interface）" class="headerlink" title="-o 输出（out interface）"></a>-o 输出（out interface）</h3><p>-o代表”output interface”<br>-o指定了数据包由哪个接口输出<br>这些数据包即将进入<code>FORWARD</code>, <code>OUTPUT</code>, <code>POSTROUTING链</code><br>如果不指定<code>-o</code>选项，那么系统上的所有接口都可以作为输出接口<br>如果出现! <code>-o eth0</code>，那么将从eth0以外的接口输出<br>如果出现<code>-i eth+</code>，那么将仅从eth开头的接口输出<br>还可以使用<code>–out-interface</code>参数</p>
<h2 id="描述规则的扩展参数"><a href="#描述规则的扩展参数" class="headerlink" title="描述规则的扩展参数"></a>描述规则的扩展参数</h2><p>对规则有了一个基本描述之后，有时候我们还希望指定端口、<code>TCP</code>标志、<code>ICMP</code>类型等内容。</p>
<h3 id="–sport-源端口（source-port）针对-p-tcp-或者-p-udp"><a href="#–sport-源端口（source-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–sport 源端口（source port）针对 -p tcp 或者 -p udp"></a>–sport 源端口（source port）针对 -p tcp 或者 -p udp</h3><ul>
<li>缺省情况下，将匹配所有端口</li>
<li>可以指定端口号或者端口名称，例如<code>–sport 22</code>与<code>–sport ssh</code>。</li>
<li><code>/etc/services</code>文件描述了上述映射关系。</li>
<li>从性能上讲，使用端口号更好</li>
<li>使用冒号可以匹配端口范围，如<code>–sport 22:100</code></li>
<li>还可以使用<code>–source-port</code></li>
</ul>
<h3 id="–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp"><a href="#–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–-dport 目的端口（destination port）针对-p tcp 或者 -p udp"></a>–-dport 目的端口（destination port）针对-p tcp 或者 -p udp</h3><ul>
<li>参数和<code>–sport</code>类似</li>
<li>还可以使用<code>–destination-port</code></li>
</ul>
<h3 id="–tcp-flags-TCP标志-针对-p-tcp"><a href="#–tcp-flags-TCP标志-针对-p-tcp" class="headerlink" title="-–tcp-flags TCP标志 针对-p tcp"></a>-–tcp-flags TCP标志 针对-p tcp</h3><ul>
<li>可以指定由逗号分隔的多个参数</li>
<li>有效值可以是：<code>SYN</code>, <code>ACK</code>, <code>FIN</code>, <code>RST</code>, <code>URG</code>, <code>PSH</code></li>
<li>可以使用<code>ALL</code>或者<code>NONE</code></li>
</ul>
<h3 id="–icmp-type-ICMP类型-针对-p-icmp"><a href="#–icmp-type-ICMP类型-针对-p-icmp" class="headerlink" title="-–icmp-type ICMP类型 针对-p icmp"></a>-–icmp-type ICMP类型 针对-p icmp</h3><ul>
<li><code>–icmp-type 0</code> 表示Echo Reply</li>
<li><code>–icmp-type 8</code> 表示Echo</li>
</ul>
<h2 id="追加规则的完整实例：仅允许SSH服务"><a href="#追加规则的完整实例：仅允许SSH服务" class="headerlink" title="追加规则的完整实例：仅允许SSH服务"></a>追加规则的完整实例：仅允许SSH服务</h2><p>本例实现的规则将仅允许SSH数据包通过本地计算机，其他一切连接（包括ping）都将被拒绝。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.清空所有iptables规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.接收目标端口为22的数据包</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.拒绝所有其他数据包</span></span><br><span class="line">iptables -A INPUT -j DROP</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="更改默认策略"><a href="#更改默认策略" class="headerlink" title="更改默认策略"></a>更改默认策略</h1><p>上例的例子仅对接收的数据包过滤，而对于要发送出去的数据包却没有任何限制。本节主要介绍如何更改链策略，以改变链的行为。</p>
<h2 id="默认链策略"><a href="#默认链策略" class="headerlink" title="默认链策略"></a>默认链策略</h2><p>警告：请勿在远程连接的服务器、虚拟机上测试！<br>当我们使用-L选项验证当前规则是发现，所有的链旁边都有<code>policy ACCEPT</code>标注，这表明当前链的默认策略为<code>ACCEPT</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh</span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure>
<p>这种情况下，如果没有明确添加DROP规则，那么默认情况下将采用ACCEPT策略进行过滤。除非：</p>
<h3 id="为以上三个链单独添加DROP规则："><a href="#为以上三个链单独添加DROP规则：" class="headerlink" title="为以上三个链单独添加DROP规则："></a>为以上三个链单独添加DROP规则：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -j DROP</span><br><span class="line">iptables -A OUTPUT -j DROP</span><br><span class="line">iptables -A FORWARD -j DROP</span><br></pre></td></tr></table></figure>
<h3 id="更改默认策略："><a href="#更改默认策略：" class="headerlink" title="更改默认策略："></a>更改默认策略：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br></pre></td></tr></table></figure>
<p>如果你严格按照上一节的例子配置了iptables，并且现在使用的是SSH进行连接的，那么会话恐怕已经被迫终止了！<br>为什么呢？因为我们已经把OUTPUT链策略更改为DROP了。此时虽然服务器能接收数据，但是无法发送数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -L</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh</span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure>
<h1 id="配置应用程序规则"><a href="#配置应用程序规则" class="headerlink" title="配置应用程序规则"></a>配置应用程序规则</h1><p>尽管5.4节已经介绍了如何初步限制除SSH以外的其他连接，但是那是在链默认策略为ACCEPT的情况下实现的，并且没有对输出数据包进行限制。本节在上一节基础上，以SSH和HTTP所使用的端口为例，教大家如何在默认链策略为DROP的情况下，进行防火墙设置。在这里，我们将引进一种新的参数-m state，并检查数据包的状态字段。</p>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.允许接收远程主机的SSH请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.允许发送本地主机的SSH响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-m state</code>: 启用状态匹配模块（state matching module）</li>
<li><code>–-state</code>: 状态匹配模块的参数。当SSH客户端第一个数据包到达服务器时，状态字段为NEW；建立连接后数据包的状态字段都是ESTABLISHED</li>
<li><code>–sport 22</code>: sshd监听22端口，同时也通过该端口和客户端建立连接、传送数据。因此对于SSH服务器而言，源端口就是22</li>
<li><code>–dport 22</code>: ssh客户端程序可以从本机的随机端口与SSH服务器的22端口建立连接。因此对于SSH客户端而言，目的端口就是22</li>
</ul>
<p>如果服务器也需要使用SSH连接其他远程主机，则还需要增加以下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.送出的数据包目的端口为22</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.接收的数据包源端口为22</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP的配置与SSH类似：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.允许接收远程主机的HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.允许发送本地主机的HTTP响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>
<h2 id="完整的配置"><a href="#完整的配置" class="headerlink" title="完整的配置"></a>完整的配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.删除现有规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.配置默认链策略</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.允许远程主机进行SSH连接</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.允许本地主机进行SSH连接</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.允许HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>kcptun 服务器配置说明</title>
    <url>/2019/11/11/kcp-tun-config/</url>
    <content><![CDATA[<h1 id="配置样例"><a href="#配置样例" class="headerlink" title="配置样例"></a>配置样例</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;listen&quot;</span>: <span class="string">&quot;:8888&quot;</span>,</span><br><span class="line"><span class="attr">&quot;target&quot;</span>: <span class="string">&quot;127.0.0.1:1080&quot;</span>,</span><br><span class="line"><span class="attr">&quot;key&quot;</span>: <span class="string">&quot;password&quot;</span>,</span><br><span class="line"><span class="attr">&quot;crypt&quot;</span>: <span class="string">&quot;salsa20&quot;</span>,</span><br><span class="line"><span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;fast&quot;</span>,</span><br><span class="line"><span class="attr">&quot;mtu&quot;</span>: <span class="number">1400</span>,</span><br><span class="line"><span class="attr">&quot;sndwnd&quot;</span>: <span class="number">1024</span>,</span><br><span class="line"><span class="attr">&quot;rcvwnd&quot;</span>: <span class="number">1024</span>,</span><br><span class="line"><span class="attr">&quot;datashard&quot;</span>: <span class="number">10</span>,</span><br><span class="line"><span class="attr">&quot;parityshard&quot;</span>: <span class="number">3</span>,</span><br><span class="line"><span class="attr">&quot;dscp&quot;</span>: <span class="number">46</span>,</span><br><span class="line"><span class="attr">&quot;nocomp&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">&quot;acknodelay&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;sockbuf&quot;</span>: <span class="number">16777217</span>,</span><br><span class="line"><span class="attr">&quot;smuxbuf&quot;</span>: <span class="number">16777217</span>,</span><br><span class="line"><span class="attr">&quot;streambuf&quot;</span>:<span class="number">16777217</span>,</span><br><span class="line"><span class="attr">&quot;smuxver&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">&quot;keepalive&quot;</span>: <span class="number">10</span>,</span><br><span class="line"><span class="attr">&quot;pprof&quot;</span>:<span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;quiet&quot;</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">&quot;tcp&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h1><table>
<thead>
<tr>
<th align="left">配项</th>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">listen</td>
<td align="left">“:33523”</td>
<td align="left">kcp server 开放的端口</td>
</tr>
<tr>
<td align="left">target</td>
<td align="left">“127.0.0.1:33522”</td>
<td align="left">本地shadowsocks 服务监听的端口</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">“igwcwmtd”</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">crypt</td>
<td align="left">“salsa20”</td>
<td align="left">salsa20对 arm芯片友好</td>
</tr>
<tr>
<td align="left">mode</td>
<td align="left">“fast”</td>
<td align="left">如不是竟技游戏，<code>fast</code>足矣</td>
</tr>
<tr>
<td align="left">mtu</td>
<td align="left">1400</td>
<td align="left">不重要，copy即可</td>
</tr>
<tr>
<td align="left">sndwnd</td>
<td align="left">1024</td>
<td align="left">不要低于512，也不要过高</td>
</tr>
<tr>
<td align="left">rcvwnd</td>
<td align="left">1024</td>
<td align="left">同上</td>
</tr>
<tr>
<td align="left">datashard</td>
<td align="left">10</td>
<td align="left"><code>datashard</code>和<code>partyshared</code> 两个数字的比，涉及到纠错理论， 3/10，实测没啥问题。过高的比重会过度放大流量</td>
</tr>
<tr>
<td align="left">parityshard</td>
<td align="left">3</td>
<td align="left">同上</td>
</tr>
<tr>
<td align="left">dscp</td>
<td align="left">46</td>
<td align="left">46 是紧急指针。让你的流量在网在公网上成为<code>VIP</code></td>
</tr>
<tr>
<td align="left">nocomp</td>
<td align="left">true</td>
<td align="left">不压缩</td>
</tr>
<tr>
<td align="left">acknodelay</td>
<td align="left">false</td>
<td align="left">不等待</td>
</tr>
<tr>
<td align="left">sockbuf</td>
<td align="left">16777217</td>
<td align="left">以下三个<code>buf</code>是缓存，如果是手机，要设置小点，1～2M就好</td>
</tr>
<tr>
<td align="left">smuxbuf</td>
<td align="left">16777217</td>
<td align="left">同上</td>
</tr>
<tr>
<td align="left">streambuf</td>
<td align="left">16777217</td>
<td align="left">同上</td>
</tr>
<tr>
<td align="left">smuxver</td>
<td align="left">2</td>
<td align="left">这里是多路复用的协议版本。选<code>2</code>，更优</td>
</tr>
<tr>
<td align="left">keepalive</td>
<td align="left">10</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">pprof</td>
<td align="left">false</td>
<td align="left">这是debug，不需要</td>
</tr>
<tr>
<td align="left">quiet</td>
<td align="left">true</td>
<td align="left">日志不需要太详细</td>
</tr>
<tr>
<td align="left">tcp</td>
<td align="left">false</td>
<td align="left">是否伪装成<code>tcp</code>连接</td>
</tr>
</tbody></table>
<h2 id="mode-特别说明"><a href="#mode-特别说明" class="headerlink" title="mode 特别说明"></a><code>mode</code> 特别说明</h2><p><code>mode</code> 项其实是 <code>nodelay</code>、<code>interval</code>、<code>resend</code>、<code>nc</code> 4项的一个组合。它们的对应关系是：</p>
<table>
<thead>
<tr>
<th align="left">mode</th>
<th align="left">nodelay</th>
<th align="left">interval</th>
<th align="left">resend</th>
<th align="left">nc</th>
</tr>
</thead>
<tbody><tr>
<td align="left">normal</td>
<td align="left">0</td>
<td align="left">40</td>
<td align="left">2</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">fast</td>
<td align="left">0</td>
<td align="left">30</td>
<td align="left">2</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">fast1</td>
<td align="left">1</td>
<td align="left">20</td>
<td align="left">2</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">fast2</td>
<td align="left">1</td>
<td align="left">10</td>
<td align="left">2</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>如果不满意于自带的4个<code>mode</code>。可以将<code>mode</code>设置为<code>manual</code>。然后就能手动定制这4项参数了！</p>
]]></content>
      <tags>
        <tag>kcp</tag>
        <tag>tun</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多个异步任务转同步</title>
    <url>/2020/03/10/java-async-sync/</url>
    <content><![CDATA[<p>Java[kotlin]对于异步的网络请求，一般采用回调来实现异步！<br>虽然，像<code>OkHttp</code>库，已经支持到了同步，但偶尔还是会碰到两种绕不过的情况：</p>
<ul>
<li>依然有很多必然是异步的场景无法绕过。如：Android的请求权限、调用相机等等。</li>
<li>多任务并发控制。<ul>
<li>并发。如：N个线程并发执行任务。当N个任务全部执行完后，再执行后续逻辑。</li>
<li>可控的并发。如：有N个任务，在M个线程中并发执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里我要绕开“线程同步锁”方案。这东西写法纷繁冗长，且考验“智商”。</p>
</blockquote>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p> 单个异步不会让代码书写得多么考验智商。当数量变成：<code>x</code>后。问题就变得不一样了。如：</p>
<ul>
<li>假设一个前提：某业务必须使用回调来完成一次请求，现有<code>n</code>个请求，逐个完成。</li>
</ul>
<p>异步实现的代码样例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isSync = <span class="literal">false</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sync</span><span class="params">(completion: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSync) &#123;</span><br><span class="line">            isSync = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">val</span> lastId = database.table(<span class="string">&quot;msgs&quot;</span>).getLast()?.msg_id ?: <span class="string">&quot;&quot;</span></span><br><span class="line">            Thread(Runnable &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                       fetchNext(lastId, completion)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                       e.printStackTrace()</span><br><span class="line">                       isSync = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;SyncWorker&quot;</span>).start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchNext</span><span class="params">(lastId: <span class="type">String</span>, completion: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = NewRequest()</span><br><span class="line">        req.query.msgId = lastId</span><br><span class="line">        Client.send(req.build()) &#123; r, ok -&gt;</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!r.hasNext) &#123;</span><br><span class="line">                    <span class="comment">// 数据已取完</span></span><br><span class="line">                    completion()</span><br><span class="line">                    isSync = <span class="literal">false</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 未取完，继续循环</span></span><br><span class="line">                    <span class="keyword">val</span> msg = NewMsgRow(r.body)</span><br><span class="line">                    database.table(<span class="string">&quot;msgs&quot;</span>).insert(msg)</span><br><span class="line">                    fetchNext(m.msgId, completion)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 请求出错，整个放弃!</span></span><br><span class="line">                completion()</span><br><span class="line">                isSync = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="异步的缺点"><a href="#异步的缺点" class="headerlink" title="异步的缺点"></a>异步的缺点</h2><ul>
<li>烧脑，也是培养Bug的温床！</li>
<li>容易滋生Bug，自然难于调试。且难以确保没有bug！</li>
<li>递归导致调用栈过深，吃不必要的内存！</li>
</ul>
<p>如果是同步的情况下，代码会很优雅。</p>
<p>同步代码样例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isSync = <span class="literal">false</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sync</span><span class="params">()</span></span> &#123;</span><br><span class="line">        isSync = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> ok = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">while</span>(!ok)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">val</span> rs = NewReuest().query(<span class="string">&quot;msgId&quot;</span>,id).send()</span><br><span class="line">                <span class="keyword">val</span> msg = NewMsgRow(rs.body)</span><br><span class="line">                database.table(<span class="string">&quot;msgs&quot;</span>).insert(msg)</span><br><span class="line">            &#125;<span class="keyword">catch</span>(e:Exception)&#123;</span><br><span class="line">                ok = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h2><p>一般情况下，操作系统还有个概念可用，那就是：“信号和量”。<br>Java的<code>Semaphore</code>，在使用 <code>await</code>时，需要调整JVM的option；不是个好选择！<br>不过，Java还提供了另一个东西：<code>CountDownLatch</code>可供选择。它的<code>await</code>就可以正常使用。</p>
<p>代码样例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步转同步</span></span><br><span class="line">    <span class="meta">@Throws(Exception::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">req</span><span class="params">(id:<span class="type">String</span>)</span></span>:Body&#123;</span><br><span class="line">        <span class="comment">// 创建一个只要一个信号的锁</span></span><br><span class="line">        <span class="keyword">val</span> c = CountDownLatch(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">var</span> e:Exception? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> rs:Body = EmptyBody()</span><br><span class="line"></span><br><span class="line">        Client.send(NewRequest()) &#123; r, err -&gt;</span><br><span class="line">            <span class="keyword">if</span>(err) e = err</span><br><span class="line">            <span class="keyword">else</span> rs = r.body</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            c.countDown()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待信号</span></span><br><span class="line">        c.await()</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) <span class="keyword">throw</span> e!!</span><br><span class="line">        <span class="keyword">return</span> rs!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异步并发控制"><a href="#异步并发控制" class="headerlink" title="异步并发控制"></a>异步并发控制</h1><p>这个信号量的<code>Semaphore</code>就可以适用了。</p>
<p>用法举例：20个任务，5个并发</p>
<p>代码样例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mutiTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建5个车道</span></span><br><span class="line">        <span class="keyword">val</span> s = Semaphore(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.20</span>)&#123;</span><br><span class="line">            <span class="comment">// 等绿灯</span></span><br><span class="line">            s.acquire()</span><br><span class="line">            Client.req(NewRequest())&#123;rs,err -&gt;</span><br><span class="line">                <span class="comment">// 处理rs,err....</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 通过后释放车道</span></span><br><span class="line">                s.release()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
        <tag>kotlin</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel Notification 测评</title>
    <url>/2016/12/15/laravel-notification/</url>
    <content><![CDATA[<p>Laravel 5.3 新出了个叫 <code>Notification</code> 的消息通知功能！先总，后分吧。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>它相对<code>event</code>的优点是：更简单也更好地隔离了不同的业务代码。且一次触发，多种’姿势’运行，不同’姿势’代码独立。</p>
<p>适合于发比较复杂的跨站消息，如：邮件、同步weibo、OA系统、第三方个人笔记Ever-note等。不只适合单发，还适合不同渠道并发。比如：同一个消息同时发送前边列出的所有渠道。</p>
<p>它还有个优点是，也能做一个Log，记录所有的发送结果。还能支持检测并记录：<strong>接收者对消息的查看状态</strong>。</p>
<p>不足的地方是：默认支持的实用工具像<code>mail</code>、<code>nexmo</code>、<code>slack</code>。除了<code>mail</code>，其它两个，我天朝子民都用不上。只能用点本地的渠道，如：<code>database</code>、<code>broadcast</code>。<br>虽然默认的有点少，但官方还搞了个<a class="link"   href="http://laravel-notification-channels.com/" >第三方消息集合的网站<i class="fas fa-external-link-alt"></i></a>。在这里能找到一堆奇葩的，常见的，拿来就能用的第三方消息扩展。<strong>但是</strong>，依旧很少有我天朝可以直接用的。乐观地看：给了你我一个完善的机会！悲观的看：自己写才是王道！总之：还是自己写！</p>
<h2 id="对象介绍"><a href="#对象介绍" class="headerlink" title="对象介绍"></a>对象介绍</h2><p>相关的类有：</p>
<p><code>Notification</code>：发出一个消息后，业务就交给它了。这里生成适合不同渠道的消息，并交给不同渠道去发送。</p>
<p><code>Channel</code>：这里定义这个渠道具体的发送流程</p>
<p><code>Message</code>：这是个格式化不同消息的助手类。如果消息体简单，可以不用它，直接在<code>Notification</code>中拼合消息体。如果消息体复杂，就有必要专门为格式化这个消息写一个<code>Message</code>Builder Helper。</p>
<h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p><code>Notification</code> 这个类laravel 的 artisan 有提供make</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class DemoNotification extends Notification</span><br><span class="line">&#123;</span><br><span class="line">    use Queueable;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Create a new notification instance.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这里返回要发多少个渠道</span><br><span class="line">     *</span><br><span class="line">     * @param  mixed  $notifiable</span><br><span class="line">     * @return array</span><br><span class="line">     */</span><br><span class="line">    public function via($notifiable)</span><br><span class="line">    &#123;</span><br><span class="line">        return [DemoChannel::class];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后边挨个渠道给生成消息，如有必要，使用Message助手</span><br><span class="line">     * 这里的命名默契地使用 &#x27;to&#x27; + 渠道名</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public function toDemo($notifiable)</span><br><span class="line">    &#123;</span><br><span class="line">        return (new DemoMessage)</span><br><span class="line">                -&gt;title(&#x27;这里是标题&#x27;)</span><br><span class="line">                -&gt;body(&#x27;这里是消息主体&#x27;)</span><br><span class="line">                -&gt;from(&#x27;发送者&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Channel</code> 每个渠道必须实现一个send($notifiable,Notification $notification) 动作</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class DemoChannel</span><br><span class="line">&#123;</span><br><span class="line">    public function send($notifiable,Notification $notification)&#123;</span><br><span class="line">        $msg = $notification-&gt;toDemo($notifiable);</span><br><span class="line">        // 后边去实现怎么把这个$msg给扔出去！</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Message</code> 命名默契地使用’Message’结尾，这个类没有约束，没有继承。完全按需发挥！</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class DemoMessage</span><br><span class="line">&#123;</span><br><span class="line">    // 按不同消息的需要自己实现啦，这个类没有约束</span><br><span class="line">    public function title($title)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    public function body($body)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>laravel</tag>
        <tag>notification</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel 队列之坑</title>
    <url>/2016/12/13/laravel-queue/</url>
    <content><![CDATA[<p>批量发消息之类的工作，很是适合放到后端，慢慢处理。那使用laravel的Queue和Job，就成为必须。</p>
<p>简单过了一下文档后，就写好了发布上线了。感觉确是不错。</p>
<p>不过近期突然爆了一个奇怪的问题，有些群发总是没完没了的重复发送。但是当我测试时，总是一切正常！</p>
<p>一时蒙了个逼！又是debug（队列的debug很是繁琐低效！）又是Google又是百度。一翻搜罗，有人说是时间的问题。</p>
<p>60s!</p>
<p>队列将一个任务发出后，如果60s内没执行完，就会认为处理过程异常。它会把这个任务再重新执行一遍！</p>
<p>嘿嘿了！</p>
<p>翻了下源码，在<code>InteractsWithQueue</code>的<code>trait</code>里发现了一个<code>delete</code>方法！</p>
<p>在我的<code>Job</code>开始<code>handle</code>后，先执行一下<code>$this-&gt;delete();</code>把这个任务删除。这样即便过了60s后，它想重新启动也没有了。这问题也就暂时解决了！</p>
<p>但是！如果这个任务处理过程中出现异常，也会丧失2次重新执行的机会。所以<em>Laravel的Job中最好只处理一件简单的原子化的事。不要在批量里处理批量。</em></p>
]]></content>
      <tags>
        <tag>laravel</tag>
        <tag>Job</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用Shell命令</title>
    <url>/2021/01/18/linux-cmd/</url>
    <content><![CDATA[<ul>
<li>找出指定文件夹下指定类型的所有文件，并全部删除<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home/user/mydir -name *.png | xargs rm -f</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Let&#39;s Encrypt 给Nginx网站加密</title>
    <url>/2017/01/12/lets-encrypt-nginx/</url>
    <content><![CDATA[<p>使用<a class="link"   href="https://certbot.eff.org/#freebsd-nginx" >certbot<i class="fas fa-external-link-alt"></i></a>管理证书。</p>
<p>在FreeBSD中安装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo pkg install certbot</span><br></pre></td></tr></table></figure>
<p>获取证书：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">certbot certonly --webroot -w /var/www/example -d example.com </span><br></pre></td></tr></table></figure>
<p>完事后，证书在：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/usr/local/etc/letsencrypt/live/example.com/</span><br></pre></td></tr></table></figure>
<p>目录中。</p>
<p>配置Nginx 虚拟机：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen     80;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    root    /var/www/example;</span><br><span class="line"></span><br><span class="line">    add_header Cache-Control no-store;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen  443 ssl;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    root /var/www/example;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ssl                  on;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /usr/local/etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /usr/local/etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_ciphers AES256+EECDH:AES256+EDH:!aNULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK！完事！最后</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo nginx -t</span><br><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>lets-encrypt</tag>
        <tag>ssl</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 命令查询网络端口占用情况</title>
    <url>/2019/07/13/macos-find-port-by-cmd/</url>
    <content><![CDATA[<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><blockquote>
<p>netstat -an | grep 80</p>
</blockquote>
<h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><blockquote>
<p>lsof -i:80</p>
</blockquote>
<blockquote>
<p>lsof -c nsqd</p>
</blockquote>
]]></content>
      <tags>
        <tag>MacOS</tag>
        <tag>lsof</tag>
        <tag>netstat</tag>
      </tags>
  </entry>
  <entry>
    <title>鼠标垫设计</title>
    <url>/2021/01/26/mouse-pad/</url>
    <content><![CDATA[<p><img src="https://user-images.githubusercontent.com/1764005/105838242-ccfcef80-600a-11eb-8a26-b07c8c7932b4.png" alt="鼠标垫"></p>
<p><a class="link"   href="https://github.com/blusewang/blog/files/5872975/psd.zip" >鼠标垫.psd.zip<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/2017/06/11/new-start/</url>
    <content><![CDATA[<p>告别wordPress！不明白这货为什么只支持MySQL！pg4wp插件的支持能力也是弱！</p>
]]></content>
  </entry>
  <entry>
    <title>为何要抛弃Kafka，选择NSQ！</title>
    <url>/2019/07/14/nsq-vs-kafka/</url>
    <content><![CDATA[<blockquote>
<p>自从抛PHP从Go。一直相安无事。近来遇到复杂业务时才想起旧爱<code>Laravel Queue</code>。<br><br>替代品有两个：<br><br>一个是名声响彻东西半球的时代宠儿：<code>Kafka</code>。<br><br>另一个是穷光蛋查理的首选：<code>NSQ</code>。</p>
</blockquote>
<h1 id="Let’s-Rock"><a href="#Let’s-Rock" class="headerlink" title="Let’s Rock"></a>Let’s Rock</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="NSQ-进程架构"><a href="#NSQ-进程架构" class="headerlink" title="NSQ 进程架构"></a>NSQ 进程架构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> +-----------------+        +---------------+</span><br><span class="line"> |                 |        |               |</span><br><span class="line"> |    nsqlookup    +&lt;-------+    nsqadmin   |</span><br><span class="line"> |                 |        |               |</span><br><span class="line"> +-------+---------+        +---------------+</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+-------------+</span><br><span class="line">| +-------------+</span><br><span class="line">| | +--------------+</span><br><span class="line">| | |              |</span><br><span class="line">+---+     nsqd     |</span><br><span class="line">  +-+              |</span><br><span class="line">    +--------------+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Kafka-进程架构"><a href="#Kafka-进程架构" class="headerlink" title="Kafka 进程架构"></a>Kafka 进程架构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">|                |</span><br><span class="line">|    zookeeper   |</span><br><span class="line">|                |</span><br><span class="line">+--------+-------+</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+-------------+</span><br><span class="line">| +-------------+</span><br><span class="line">| | +--------------+</span><br><span class="line">| | |              |</span><br><span class="line">+---+    kafka     |</span><br><span class="line">  +-+              |</span><br><span class="line">    +--------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="资源消耗"><a href="#资源消耗" class="headerlink" title="资源消耗"></a>资源消耗</h2><ul>
<li>环境：FreeBSD12</li>
<li>测量工具：htop RES</li>
</ul>
<h3 id="NSQ"><a href="#NSQ" class="headerlink" title="NSQ"></a>NSQ</h3><table>
<thead>
<tr>
<th>进程</th>
<th>启动时占用</th>
</tr>
</thead>
<tbody><tr>
<td>nsqd</td>
<td>9.2MB</td>
</tr>
<tr>
<td>nsqlookup</td>
<td>8.5MB</td>
</tr>
</tbody></table>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><table>
<thead>
<tr>
<th>进程</th>
<th>启动时占用</th>
</tr>
</thead>
<tbody><tr>
<td>kafka</td>
<td>299MB</td>
</tr>
<tr>
<td>zookeeper</td>
<td>58MB</td>
</tr>
</tbody></table>
<h2 id="运行与维护"><a href="#运行与维护" class="headerlink" title="运行与维护"></a>运行与维护</h2><table>
<thead>
<tr>
<th>\</th>
<th>NSQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>依赖</td>
<td>无</td>
<td>Linux基础包、bash、jdk、java</td>
</tr>
<tr>
<td>耦合</td>
<td>无！能以nsqd单进程提供完整服务，只在多节点分布式模式下需要nsqlookup</td>
<td>依赖 zookeeper</td>
</tr>
<tr>
<td>日志</td>
<td>标准输出，自行重定向</td>
<td>zookeeper 1份日志，kafka 7份日志，其中两份日志按小时自动切割</td>
</tr>
<tr>
<td>配置</td>
<td>10项左右，默认即是最优</td>
<td>10多个独立配置文件，数百个配置项</td>
</tr>
<tr>
<td>性能优化</td>
<td>默认开启 pprof。支持web可视化实时观测内存、协程等动态</td>
<td>无</td>
</tr>
<tr>
<td>异常排查</td>
<td>错误日志中的栈，源码量小。不依赖网络问答也能在短时间内找出问题</td>
<td>错误日志中的栈，深度的栈，巨量源码，排查需要深入了解其原理，大量阅读源码。否则只能通过互联网、查阅前人经验或大师级人脉。</td>
</tr>
</tbody></table>
<h2 id="业务能力"><a href="#业务能力" class="headerlink" title="业务能力"></a>业务能力</h2><table>
<thead>
<tr>
<th>\</th>
<th>NSQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>数据安全</td>
<td>单个nsqd实例内的数据，不支异地热备，实例在正常退出时，会做刷入磁盘操作，也有手动备份实例数据的工具。</td>
<td>数据全在磁盘。多个节点间自动互为备份。</td>
</tr>
<tr>
<td>消息顺序</td>
<td>不保证有序</td>
<td>支持有条件的有序</td>
</tr>
<tr>
<td>消息投递</td>
<td>至少一次，消费者需自行保持消息处理的幂等</td>
<td>支持准确的一次</td>
</tr>
</tbody></table>
<ul>
<li>附加能力</li>
</ul>
<table>
<thead>
<tr>
<th>\</th>
<th>NSQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>界面化管理</td>
<td>自带nsqadmin</td>
<td>无，需额外安装第三方包</td>
</tr>
<tr>
<td>基于http协议的pub</td>
<td>nsqd自带</td>
<td>无，需额外安装第三方包</td>
</tr>
</tbody></table>
<hr>
<h2 id="一个Goer视角的体验"><a href="#一个Goer视角的体验" class="headerlink" title="一个Goer视角的体验"></a>一个Goer视角的体验</h2><p>kafka 的golang client 官方首推 sarama。一查就出糙点：<a class="link"   href="https://blog.wolfogre.com/posts/golang-consume-kafka/" >golang 消费 kafka 的坑<i class="fas fa-external-link-alt"></i></a><br>这些库的版本，1.0都不到。</p>
<p>而<a class="link"   href="https://github.com/nsqio/go-nsq" >go-nsq<i class="fas fa-external-link-alt"></i></a>截至当前已经历16次release至v1.0.7。适用度，亲测为上好！</p>
<h3 id="NATS队列"><a href="#NATS队列" class="headerlink" title="NATS队列"></a>NATS队列</h3><p>by the way 顺便提一下NATS队列，也很有名。它的消息投递既支持至少一次，也支持最多一次，也无法准确的一次。</p>
<h3 id="何时该选择Kafka"><a href="#何时该选择Kafka" class="headerlink" title="何时该选择Kafka"></a>何时该选择Kafka</h3><p>Kafka隶属于Apache基金会。是Apache“全家桶”的一员。</p>
<p>Apache家族拥有除了队列之外，在可靠计算和大数据方面有着可靠、开放的整体解决方案。就像ARM的公版。</p>
<p>Java开发者是个遍布全球的庞大工人群体。</p>
<p>因此，选择Apache下的产品具有工业化特征，是一个只要<strong>肯花钱</strong>，就一定能实现的高度可复制的生产机器。</p>
<h3 id="身为Goer-自豪地采用NSQ！"><a href="#身为Goer-自豪地采用NSQ！" class="headerlink" title="身为Goer 自豪地采用NSQ！"></a>身为Goer <strong>自豪地采用<code>NSQ</code>！</strong></h3><ul>
<li>在云服务成熟的今天，主机意外断电，且断电后硬盘也意外消失的可能几乎为0。再加上阿里云的定时自动快照。倘若是金融、保险类的业务，还可以通过其它手段，如：文件同步备份的方式做热备。</li>
<li>成本。不论是运维成本，还是硬件成本，NSQ都吊打Kafka！相比之下保持幂等的成本，就不是事儿了。</li>
</ul>
]]></content>
      <tags>
        <tag>Kafka</tag>
        <tag>NSQ</tag>
      </tags>
  </entry>
  <entry>
    <title>NSQ的部署</title>
    <url>/2019/07/15/nsq-deploy/</url>
    <content><![CDATA[<h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><ul>
<li>系统：FreeBSD 12</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg install nsq</span><br></pre></td></tr></table></figure>
<h3 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h3><ul>
<li>NSQ 配置文件样例：<a class="link"   href="https://github.com/nsqio/nsq/tree/master/contrib" >https://github.com/nsqio/nsq/tree/master/contrib<i class="fas fa-external-link-alt"></i></a></li>
<li>部署在<code>/usr/local/etc/</code>下<ul>
<li>nsqd.conf</li>
<li>nsqlookup.conf</li>
<li>nsqadmin.conf</li>
</ul>
</li>
</ul>
<h3 id="应用配置文件"><a href="#应用配置文件" class="headerlink" title="应用配置文件"></a>应用配置文件</h3><p>在<code>/usr/local/etc/rc.d/</code>下找到对应的服务管理脚本。</p>
<p>会看到下面的头部：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $FreeBSD: branches/2019Q2/net/nsq/files/nsqd.in 454856 2017-11-24 23:17:50Z dbaio $</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># PROVIDE: nsqd</span></span><br><span class="line"><span class="comment"># REQUIRE: LOGIN</span></span><br><span class="line"><span class="comment"># KEYWORD: shutdown</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the following lines to /etc/rc.conf to enable nsqd:</span></span><br><span class="line"><span class="comment"># nsqd_enable=&quot;YES&quot;</span></span><br><span class="line"><span class="comment"># nsqd_args=&quot;&lt;set as needed&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在此将</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nsqd_enable=&quot;YES&quot;</span></span><br><span class="line"><span class="comment"># nsqd_args=&quot;&lt;set as needed&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nsqd_enable=<span class="string">&quot;YES&quot;</span></span><br><span class="line">nsqd_args=<span class="string">&quot;--config=/usr/local/etc/nsqd.conf&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><code>service nsqd start</code></p>
]]></content>
      <tags>
        <tag>NSQ</tag>
      </tags>
  </entry>
  <entry>
    <title>编译OpenWRT</title>
    <url>/2020/03/10/openwrt-compile/</url>
    <content><![CDATA[<p>之前编译OpenWRT时有很多顾虑。比如：</p>
<ul>
<li>太多依赖，担心把自己MacOS装太多不明用处的包。将来无法清理</li>
<li>担心搞不懂编译过程中遇到的陌生概念。比如：出一个问题，google一下，得到了10个问题！</li>
<li>不知道编译结果是什么。如何把编译结果变成指定的系统镜像。不相信<code>make</code>能直接出镜像。</li>
</ul>
<p>事实上，OpenWRT 团队是群非常实在的人！只需要一次<code>make</code>多版本的IMG镜像和选中的软件包。全编译出来并打好包，还整理得非常整齐！</p>
<p><a class="link"   href="https://openwrt.org/zh-cn/doc/howto/build" >官方的中文编译说明<i class="fas fa-external-link-alt"></i></a>这里展示了准备好后的编译过程。由此文可见，确实不难！当然，仅凭此一文，不足以指导完成编译！</p>
<p>下边记录一下我的编译经历。</p>
<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><p>选择在虚拟机里编译。免得污染OS。</p>
<ul>
<li>虚拟机选择VirtualBox；因为免费稳健。</li>
<li>编译OS，选择Alpine Linux；因为它小且便于安装。<ul>
<li>OpenWRT编译支持几乎所有常见Linux发行版和MacOS。FreeBSD官方文档立了项，但没有写，就此略过。Windows没有看到相关文档。</li>
</ul>
</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>虚拟机尽量多给几个CPU核心，因为OpenWRT项目相当大！更多的核心能压缩编译时间。</li>
<li>虚拟机硬盘给15GB以上，最好20GB以上。</li>
<li>给装好的OS建立一个新用户。OpenWRT官方不推荐在<code>root</code>账号下编译。</li>
<li>源码中依赖的第三方库，多数在海外。一架舒适的小飞机，是理想的选择；甚至是必须！</li>
</ul>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>以下要求，不在本文探讨范围。</p>
<ul>
<li>要会用VirtualBox。</li>
<li>要会安装Alpine Linux。</li>
<li>要会用git。理解分支和标签的概念和用法。</li>
<li>自备小飞机。</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li>虚拟机环境准备参考：<a class="link"   href="https://openwrt.org/docs/guide-developer/build-system/install-buildsystem" >Build system – Installation<i class="fas fa-external-link-alt"></i></a></li>
<li>编译过程及选项参考：<a class="link"   href="https://openwrt.org/docs/guide-developer/build-system/use-buildsystem" >Build system – Usage<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h1 id="重点提示："><a href="#重点提示：" class="headerlink" title="重点提示："></a>重点提示：</h1><ul>
<li>环境准备，在装完OS后，其实很简单。只要在<a class="link"   href="https://openwrt.org/docs/guide-developer/build-system/install-buildsystem" >Build system – Installation<i class="fas fa-external-link-alt"></i></a>文章中复制一下对应的安装指令，执行一下；再找个地方clone出源码即可。</li>
<li><code>git tag</code>查找需要的版本。<code>git checkout</code>需要的版本。</li>
<li><code>./scripts/feeds</code> feeds 指令是管理Apk（OpenWRT上的安装包）的。就像MacOS上的<code>brew</code>。在<code>menuconfig</code>之前值得更新一下，<code>./scripts/feeds update -a</code>。</li>
<li>自己的安装包将来也是在这里创建和管理、编译。</li>
<li><code>make menuconfig</code> 有UI界面，可在UI界面上选择要编译的镜像的目标设备。如：选择<code>brcm2708</code>是<code>Raspberry Pi</code>类型的芯片，子类型对应<code>Raspberry Pi</code>的不同Model版本，如：<code>bcm2710</code>是<code>Raspberry Pi 3</code>的芯片型号。</li>
<li><code>make defconfig</code> 设置默认项</li>
<li><code>make kernel_menuconfig</code> 望文生义，内核配置，一般不需要。</li>
<li><code>make download</code> 下载源码编译过程中依赖的工具。</li>
<li>在<code>make download</code>前，配置一下<code>wget</code>的<code>http_proxy``https_proxy``ftp_proxy</code>，并启用<code>proxy</code>。<code>wget</code>配置文件在：<code>/etc/wgetrc</code></li>
<li><code>make</code> </li>
<li>参数<code>-j3</code>，就是3个线程并发编译，这个数字取决于CPU。</li>
<li>参数<code>V=s</code>，是显示详细。</li>
<li>参数<code>package/cups/compile</code>，是编译单个应用。</li>
</ul>
<h1 id="我的编译成果"><a href="#我的编译成果" class="headerlink" title="我的编译成果"></a>我的编译成果</h1><h2 id="固件特点"><a href="#固件特点" class="headerlink" title="固件特点"></a>固件特点</h2><ul>
<li>固件型号：    <strong>Raspberry Pi 4 Model B Rev 1.2</strong></li>
<li>1GB 根空间。</li>
<li>镜像内置了USB转rj45驱动</li>
<li>默认支持<code>bbr</code>、<code>tcpdump</code></li>
<li>支持<code>v2ray</code>，在配置好源后，<code>opkg update &amp;&amp; opkg install v2ray</code>就能得到。</li>
<li>广告过滤</li>
<li>分流</li>
<li>屏蔽大厂部分产品的日志收集</li>
<li>出口配置样例</li>
<li>编译了package中部分我认为常用的包，如：<code>luci-app-statistics</code>、<code>6to4</code>、<code>htop</code>、<code>curl</code>、<code>fdisk</code>、<code>cfdisk</code>、<code>ffmpeg</code>、<code>luci-app-samba</code>等。</li>
</ul>
<h2 id="固件源"><a href="#固件源" class="headerlink" title="固件源"></a>固件源</h2><p>固件下载、升级：<a class="link"   href="http://openwrt.wangjunfeng.com.cn/targets/bcm27xx/bcm2711/" >http://openwrt.wangjunfeng.com.cn/targets/bcm27xx/bcm2711/<i class="fas fa-external-link-alt"></i></a></p>
<p><code>/etc/opkg/distfeeds.conf</code> 源配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;gz jf_core http:&#x2F;&#x2F;openwrt.wangjunfeng.com.cn&#x2F;targets&#x2F;bcm27xx&#x2F;bcm2711&#x2F;packages</span><br><span class="line">src&#x2F;gz jf_base http:&#x2F;&#x2F;openwrt.wangjunfeng.com.cn&#x2F;packages&#x2F;aarch64_cortex-a72&#x2F;base</span><br><span class="line">src&#x2F;gz jf_luci http:&#x2F;&#x2F;openwrt.wangjunfeng.com.cn&#x2F;packages&#x2F;aarch64_cortex-a72&#x2F;luci</span><br><span class="line">src&#x2F;gz jf_packages http:&#x2F;&#x2F;openwrt.wangjunfeng.com.cn&#x2F;packages&#x2F;aarch64_cortex-a72&#x2F;packages</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>openWRT</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenWRT实现内网tcp连接请求整形 搭建逼真开发环境</title>
    <url>/2020/08/04/openwrt-ipv6-firewall-forward/</url>
    <content><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="头疼的配置"><a href="#头疼的配置" class="headerlink" title="头疼的配置"></a>头疼的配置</h2><p>开发者本地开发一款网络应用时，一般是在测试时，使用测试域名/IP。发布时使用正式域名/IP。</p>
<p>看似简单的小操作。但在多轮迭代时，这个小操作一但出错，会出大问题。</p>
<p>如果开发环境配置与生产环境完全一样，那就省事许多。</p>
<p>在有自己可控的内网路由情况下，实现起来，一般有两种方式：DNS劫持、IP劫持。</p>
<h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><p>只需在登入OpenWRT后，把域名新的解析写入 <code>/etc/hosts</code> 。再 <code>/etc/init.d/dnsmasq reload</code> 重载一下<code>dnsmasq</code>就好了。简单好用！</p>
<h2 id="IP劫持"><a href="#IP劫持" class="headerlink" title="IP劫持"></a>IP劫持</h2><p>这个相对复杂一些。因为在OpenWRT的 <code>网络 - 防火墙 - NAT 规则</code> 只支持重写源地址，不支持重写目标地址。</p>
<p>这就得手动写<code>网络 - 防火墙 - 自定义规则</code>了！</p>
<h3 id="IPv4劫持"><a href="#IPv4劫持" class="headerlink" title="IPv4劫持"></a>IPv4劫持</h3><p>IPv4的规则直接写就可以，例如：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -i br-lan -d 1.2.3.4 -p tcp -m tcp --dport 443 -m comment --comment &quot;dev&quot; -j DNAT --to-destination 192.168.1.2:443</span><br></pre></td></tr></table></figure>
<h3 id="IPv6劫持"><a href="#IPv6劫持" class="headerlink" title="IPv6劫持"></a>IPv6劫持</h3><p>IPv6就麻烦些了。因为IPv6设计目标就是弃用<code>NAT</code>（因为有几乎无穷的地址资源）。<br>虽然按标准应该不用，但依旧有<code>热心人</code>对它进行了实现。</p>
<p>在<code>系统 - 软件包</code>里搜索并安装：<code>kmod-ipt-nat</code> <code>ip6tables-mod-nat</code>。这就具备了对IPv6进行<code>NAT</code>的能力了！</p>
<p>但不能直接写规则；需先开启发住内网的v6的伪装。例如：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">ip6tables -t nat -I POSTROUTING -o br-lan -j MASQUERADE</span><br></pre></td></tr></table></figure>
<p>再给从内网发出的包写具体规则；例如：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">ip6tables -t nat -A PREROUTING -i br-lan -d 2408:4002:xx::xx -p tcp -m tcp --dport 443 -m comment --comment &quot;dev&quot; -j DNAT --to-destination [2408:8207:xx:xx::2]:443</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ipv6</tag>
        <tag>ip6tables</tag>
        <tag>OpenWRT</tag>
      </tags>
  </entry>
  <entry>
    <title>RaspberryPI上安装OpenWRT</title>
    <url>/2019/12/04/openwrt-on-raspberry-pi/</url>
    <content><![CDATA[<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>家用网络拓扑设计</p>
<pre class="mermaid">graph LR
lt((联通宽带))
subgraph Raspberry PI
openwrt(OpenWRT)
end
tp(TP-Link)
mac(Laptop)
phone(Phone)
subgraph Raspberry PI 2
osmc(OSMC Dodi)
end
tv(TV)
disk[(USB 硬盘)]

lt ---|光猫桥接| openwrt
openwrt ---|USB转网线| tp
openwrt --- disk
tp -. wifi .- mac
tp -. wifi .- phone
tp ---|网线| osmc
osmc ---|HDMI| tv 
openwrt -. wifi .- mac
openwrt -. wifi .- phone</pre>

<p>路由器连接RPI由网线接口。RPI连接电视由HDMI接口。</p>
<h1 id="配件准备"><a href="#配件准备" class="headerlink" title="配件准备"></a>配件准备</h1><p>唯独RPI连接路由器。额外需要一个 USB转网口。<br>淘宝之：<br><img src="https://gd4.alicdn.com/imgextra/i4/4282361926/O1CN0184Ycaa1Q69NjPfQVD_!!4282361926.png_400x400.jpg" alt="image"><br><a class="link"   href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.2b562e8d64yuA7&id=597724398426&_u=416uj6v1a71" >树莓派USB2.0 HUB 网卡加hub 分线器转RJ45外置有线网卡 USB网口<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="刷OS"><a href="#刷OS" class="headerlink" title="刷OS"></a>刷OS</h1><p>OpenWRT 官方提供了详细的解说。<br><a class="link"   href="https://openwrt.org/toh/raspberry_pi_foundation/raspberry_pi" >OpenWrt Project: Raspberry Pi<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>启动后。通过web连接至OpenWRT。</p>
<h2 id="设置USTC源"><a href="#设置USTC源" class="headerlink" title="设置USTC源"></a>设置USTC源</h2><p>在【系统】-【软件包】-【配置】将软件源全替换为USTC源。</p>
<ul>
<li><p><a class="link"   href="https://mirrors.ustc.edu.cn/help/lede.html" >USTC配置帮助<i class="fas fa-external-link-alt"></i></a><br>配置效果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">src/gz openwrt_core http://mirrors.ustc.edu.cn/lede/releases/18.06.5/targets/arm_arm1176jzf-s_vfp/packages</span><br><span class="line">src/gz openwrt_base http://mirrors.ustc.edu.cn/lede/releases/18.06.5/packages/arm_arm1176jzf-s_vfp/base</span><br><span class="line">src/gz openwrt_luci http://mirrors.ustc.edu.cn/lede/releases/18.06.5/packages/arm_arm1176jzf-s_vfp/luci</span><br><span class="line">src/gz openwrt_packages http://mirrors.ustc.edu.cn/lede/releases/18.06.5/packages/arm_arm1176jzf-s_vfp/packages</span><br><span class="line">src/gz openwrt_routing http://mirrors.ustc.edu.cn/lede/releases/18.06.5/packages/arm_arm1176jzf-s_vfp/routing</span><br><span class="line">src/gz openwrt_telephony http://mirrors.ustc.edu.cn/lede/releases/18.06.5/packages/arm_arm1176jzf-s_vfp/telephony</span><br></pre></td></tr></table></figure>
<h2 id="安装需要的包"><a href="#安装需要的包" class="headerlink" title="安装需要的包"></a>安装需要的包</h2></li>
<li><p>中文语言包：luci-i18n-base-zh-cn</p>
</li>
<li><p>USB转网口：kmod-usb-net-rtl8152</p>
</li>
<li><p>开启BBR：kmod-tcp-bbr</p>
</li>
</ul>
<h2 id="编译V2ray"><a href="#编译V2ray" class="headerlink" title="编译V2ray"></a>编译V2ray</h2><p>v2ray的arm版对不同版本芯片支持不完整。辣么，自己动手！<br>查看芯片信息：<code>cat /proc/cpuinfo</code><br>参考<a class="link"   href="https://www.v2ray.com/developer/intro/compile.html#manualbuild" >手工构建<i class="fas fa-external-link-alt"></i></a><br>参考<a class="link"   href="https://github.com/golang/go/wiki/GoArm" >golang ARM芯片构建支持情况<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>源码准备：<code>go get github.com/v2ray/v2ray-core</code></li>
<li>编译<code>v2ray</code>：<code>GOPROXY=https://goproxy.io CGO_ENABLED=0 GOOS=linux GOARCH=arm GOARM=6 go build -o $HOME/v2ray -ldflags &quot;-s -w&quot;</code></li>
<li>编译<code>v2ctl</code>：<code>GOPROXY=https://goproxy.io CGO_ENABLED=0 GOOS=linux GOARCH=arm GOARM=6 go build -o $HOME/v2ctl -ldflags &quot;-s -w&quot; -tags confonly </code></li>
</ul>
]]></content>
      <tags>
        <tag>OpenWRT</tag>
        <tag>RaspberryPi</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenWRT 在 RaspberryPI 播放音频</title>
    <url>/2020/07/06/openwrt-on-raspberrypi-play-audio/</url>
    <content><![CDATA[<p>RaspberryPI 不只能满足路由计算需要，还能用于多媒体，如：插上音箱放音乐！</p>
<h1 id="OpenWrt编译要求"><a href="#OpenWrt编译要求" class="headerlink" title="OpenWrt编译要求"></a>OpenWrt编译要求</h1><h2 id="内核驱动类要求："><a href="#内核驱动类要求：" class="headerlink" title="内核驱动类要求："></a>内核驱动类要求：</h2><ul>
<li>Kernel modules &gt; Sound Support &gt; kmod-sound-core</li>
<li>Kernel modules &gt; Sound Support &gt; kmod-sound-arm-bcm2835<h2 id="软件要求"><a href="#软件要求" class="headerlink" title="软件要求"></a>软件要求</h2></li>
<li>Sound &gt; alsa-utils</li>
<li>Sound &gt; madplay</li>
</ul>
<h1 id="Raspberry-PI-设置"><a href="#Raspberry-PI-设置" class="headerlink" title="Raspberry PI 设置"></a>Raspberry PI 设置</h1><h2 id="开放设备"><a href="#开放设备" class="headerlink" title="开放设备"></a>开放设备</h2><p>在 <code>/boot/config.txt</code> 里添加如下行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dtparam=audio=on</span><br></pre></td></tr></table></figure>
<p>使Raspberry PI开放音频硬件。不然有驱动程序，但找不到音频设备！</p>
<h2 id="设置音频输出"><a href="#设置音频输出" class="headerlink" title="设置音频输出"></a>设置音频输出</h2><p>通过<code>amixer</code>命令完成：</p>
<p><code>$ amixer cset numid=3 1</code> ：指定音频输出接口为 3.5mm 耳机接口<br><code>$ amixer cset numid=3 2</code> ：指定音频输出接口为 HDMI</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> madplay music.mp3</span></span><br><span class="line">  MPEG Audio Decoder 0.15.2 (beta) - Copyright (C) 2000-2004 Robert Leslie et al.</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>OpenWRT</tag>
        <tag>RaspberryPi</tag>
        <tag>音频</tag>
      </tags>
  </entry>
  <entry>
    <title>plan 9 效应 - 为什么功能没坏，你就不该去重构它！</title>
    <url>/2019/08/05/plan-9-effect/</url>
    <content><![CDATA[<p>Plan-9是一个很棒的、很先进的，而且完全是全新实现的Unix系统，它的目的就是要最终解决Unix最初的诺言：一切皆为文件。你听说过这套系统吗？没有？那好，下面就是为什么。</p>
<p>我十分确信你不知道Plan-9是什么东西，并且很有可能你还是第一次听说这个名字。</p>
<p>Plan-9是一款神奇的新版Unix，几乎是由70年代当初开发Unix系统的同一个团队开发的。它的确是一款非常酷的操作系统。它跟Unix非常相似，但它不是Unix，它纠正了Unix系统里很多不一致的、古怪的、至今仍然存在的特性。</p>
<p>Unix在当初立项时有个这样的许诺：系统里任何的东西都是‘文件’——根据某些文件的定义。例如，sockets，也许称作网络连接更合适，它们就不是文件，进程也不是文件。</p>
<p>在Plan-9中，所有的这些问题都解决了！先进的9P虚拟文件系统协议最终让所有东西都成为了文件。目录变成了“命名空间”，资源被映射成了文件。多么神奇！现在，你可以通过对/proc目录(现在应该成其为一个命名空间)里的一个文件使用“cat”命令来查看进程的情况。同样，打开一个网络连接的方式变成了打开/net/tcp目录里的一个文件，这就是它。”iotcl”系统调用在这个系统里完全被根除了，因为基于操作系统上的现代文件形式中的这种怪胎已经不再需要了。</p>
<h2 id="那么，为什么你从来没有听说过这样一款神奇的操作系统呢？"><a href="#那么，为什么你从来没有听说过这样一款神奇的操作系统呢？" class="headerlink" title="那么，为什么你从来没有听说过这样一款神奇的操作系统呢？"></a>那么，为什么你从来没有听说过这样一款神奇的操作系统呢？</h2><p>你从来没有听说过它的原因是，它并不是一款成功的操作系统。这怎么可能呢？是这样的，是因为Plan-9实际上没有解决任何问题。在Unix世界里，从来没有人抱怨说Unix没有兑现当初关于文件抽象的诺言。</p>
<p>在随后的日子里，Plan-9里的/proc文件系统概念被人移植到到了Solaris等很多其他商业版Unix系统里(Linux也采用了它)。 Plan-9里另外一个非常著名的首创——UTF-8——被迅速的被众多其它操作系统采用，不仅仅是Unix家族。在所有的操作系统里，即使存在一些由于各种原因没有采用UTF-8的，它们也开发出来将UTF-8和本地编码转换的程序库。</p>
<p>Plan-9的对于网络通信的特殊的处理方式需要在这里特别的说明一下。虽然用基于命名空间/文件系统的方式来代替专用API来处理网络操作，听起来很吸引人，但是整个Unix世界，不仅所有人都已经接受了使用伯克利Socket API做为标准方式来进行网络编程，甚至Windows平台也实现了几乎相同的API里简化各种网络应用向Windows上移植——虽然存在一些小问题。</p>
<p>更重要的是，Plan-9发明的这种与众不同的网络编程编程方式在诞生之日就注定了毫无用处。因为在当时，大部分做网络编程的人都已经转向了更高的网络抽象层。RPC和Corba已经诞生，所有的需要跟远程服务器通信的应用全都转向了它们。程序员为了跟远程服务通信时需要打开sockets的机会越来越少，所有的他们都已经习惯了使用Berkeley API。(旁注：曾经有一个POSIX模拟层，叫做APE“ANSI/POSIX Environment”，试图将Plan-9上的某些功能映射到POSIX对应的功能上。这个模拟层一直都没实现，因为一些应用——例如X11——的迁移过于复杂，不可能完成。“维持它正确运行的工作量太过巨大”——维基百科。)</p>
<p>Plan-9的一个最主要的问题出在AT&amp;T和Unix幕后的这群人身上，尽管他们都是才华横溢的科学家和程序员，但他们不懂得如何去开发商业软件，而AT&amp;T也从来没打算进入软件业。这些，我承认听起来有些大不敬，但事实就是这样。他们使用软件，他们喜欢开发内部软件来运行他们的高端网络设备，但是他们却从来不去开发要卖给别人的软件，而且跟Sun，IBM，微软等商业公司不一样，这从来不是他们的资金的主要来源。这就意味着他们不需要有外部世界需要什么样的软件的意识。举个例子，Sun公司就需要这样的意识，所以他们开发出了RPC。他们认识到人们在进行网络编程时很痛苦，他们看到了创建一个网络抽象层的商业机会：“嗨，大伙们，SunOS有一个很酷的东西，让我们能够不直接跟sockets打交道就可以开发出网络应用！你绝对应该使用SunOS”。</p>
<p>还有，在Plan-9中，很多“好的老的东西”被删除了，大量的跟其它Unix不兼容的东西被加入了系统。这几乎打消了众多公司试图将他们的应用迁移到Plan-9的念头。如果你不知道这样一个新系统是否能够获得成功，那为什么要耗费了大量的工作把自己的应用迁移到这个新平台上呢？这就是典型的鸡生蛋蛋生鸡问题：一个操作系统的价值就在于上面有大量应用可运行，无它。如果一个系统很新，你要做的是必须发展一个能够支持各种应用的生态系统，通过它们让这个系统变得有价值。只有两条路能做到这样。第一个就是让这个系统跟目前现存的系统保持最大的兼容，也就是Unix， POSIX 和 Motif 这些系统。第二个就是创建自己的生态系统，以此来提升新系统的价值，微软Windows和Office办公系统软件就是典型例子。</p>
<h2 id="我们应该从Plan-9的历史教训中总结出一些经验吗？"><a href="#我们应该从Plan-9的历史教训中总结出一些经验吗？" class="headerlink" title="我们应该从Plan-9的历史教训中总结出一些经验吗？"></a>我们应该从Plan-9的历史教训中总结出一些经验吗？</h2><p>当然，我们至少可以获得下面这些：</p>
<ul>
<li>首先是，不要试图去修改那些没有坏或你认为不够好的东西，如果要修，只去修改出问题的部分，不要去修改看起来很笨——但事实上是在按要求工作的东西。例如，UTF-8是个非常棒的创意，你需要它，但你可以用程序库或子系统实现它，这样其它系统也能使用它，而不是去基于这个编码开发出一套全新的操作系统。</li>
<li>第二个是，在开发一个你的系统前，先去搞清楚它是否有市场，或者人们是否需要这个东西。例如，/net/tcp文件系统绝对是一个精彩的纯学术课题，如果是早几年，它一定能完胜Berkeley sockets，但不应该是在直接使用Socket的人群已经没剩几个的时候。</li>
<li>第三，要么完全的独立自主，要么跟现有的系统保持最大兼容。但Plan-9却处在它完全不应该的位置：中间。这套系统既不跟现有的所有Unix系统兼容，同时也不提供其它Unix系统中都有的、必要的工具。没有高级文本编辑器、表格软件、CAD程序和服务器软件。它就是一个神奇的空盒子，却没有提供任何方法让人们容易的把东西放进去。</li>
</ul>
<p>这些看起来都是一些非常高层的东西，并不是特别跟程序员的日常开发相关。看起来是这样，但事实远非如此。现如今，你可以很容易的开创自己的事业，开始向用户提供某种的服务。然而，你的服务是一个有价值的产品？还是变成了另外一个Plan-9传奇？这并不是很容易判断的事。例如，你的打算开发一个报表系统，来展现监控数据或其它任何可视的状态，如果你没有提供用它将这些报表导入到Excel的功能，那你在写第一行代码前就输了。如果你打算开发一个新的Web社交应用，而你没有提供使用Fackbook、Twitter或LinkedIn登录的方式，那你在搭建WEB服务器前就输了。如果你web服务中信息的导出方式没有采用RSS或ATOM，而是采用了一种全新的格式，猜会怎么样？你在吸引到第一个用户前就输了。但是，比着一切更重要的是：你的产品真正的解决了一个现实存在的问题吗？</p>
<p>翻译自：<a class="link"   href="http://www.di.unipi.it/~nids/docs/the_plan-9_effect.html" >The Plan-9 Effect or why you should not fix it if it ain’t broken<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>plan9</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 外部表</title>
    <url>/2018/09/07/postgres_fdw/</url>
    <content><![CDATA[<p>是时候用一下PG外部表了。这些年过去，这功能应该是稳定了的。</p>
<h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><p>首先确定contrib是否有安装。如果没有要先安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg install postgresql10-contrib</span><br></pre></td></tr></table></figure>
<p>然后开启扩展</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION postgres_fdw;</span><br></pre></td></tr></table></figure>
<h2 id="创建远程服务"><a href="#创建远程服务" class="headerlink" title="创建远程服务"></a>创建远程服务</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SERVER server156</span><br><span class="line">  <span class="keyword">FOREIGN</span> DATA WRAPPER postgres_fdw</span><br><span class="line">OPTIONS (host <span class="string">&#x27;192.168.1.156&#x27;</span>,dbname <span class="string">&#x27;bossdb&#x27;</span>,port <span class="string">&#x27;5432&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这里有个坑,就是如果192.168.1.156连不上的情况下上面语句也会执行成功.其实真正的连接到远程服务器是要等到后面dml执行时才会连接</p>
<h2 id="创建用户映射"><a href="#创建用户映射" class="headerlink" title="创建用户映射"></a>创建用户映射</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> MAPPING <span class="keyword">FOR</span> postgres</span><br><span class="line">  SERVER server156</span><br><span class="line">  OPTIONS (<span class="keyword">user</span> <span class="string">&#x27;postgres&#x27;</span>,password <span class="string">&#x27;000000&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这里如果输错了也不会知道。</p>
<h2 id="创建远程表"><a href="#创建远程表" class="headerlink" title="创建远程表"></a>创建远程表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN</span> <span class="keyword">TABLE</span> if <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> qbit_test (</span><br><span class="line">  id <span class="type">INTEGER</span>  ,</span><br><span class="line">  name <span class="type">CHARACTER</span> <span class="type">VARYING</span>(<span class="number">50</span>),</span><br><span class="line">  class <span class="type">CHARACTER</span> <span class="type">VARYING</span>(<span class="number">50</span>),</span><br><span class="line">  <span class="type">time</span> <span class="type">CHARACTER</span> <span class="type">VARYING</span>(<span class="number">50</span>)</span><br><span class="line">)</span><br><span class="line">  SERVER server156</span><br><span class="line">OPTIONS (schema_name <span class="string">&#x27;public&#x27;</span>,table_name <span class="string">&#x27;qbit_test&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>FDW</tag>
        <tag>外部表</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 上安装 PostgreSQL 10</title>
    <url>/2018/04/09/postgresql-10-install-ubuntu/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>支持中文</li>
<li>自定义日志</li>
<li>初始密码</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先按<a class="link"   href="https://www.postgresql.org/download/linux/ubuntu/" >PostgreSQL<i class="fas fa-external-link-alt"></i></a>官方指引在Ubuntu上安装好源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install language-pack-zh-hans postgresql-10 postgresql-server-dev-10</span><br><span class="line">sudo vim /etc/default/locale</span><br><span class="line"><span class="comment"># + LANG=zh_CN.utf8</span></span><br><span class="line">sudo su - postgres</span><br><span class="line">initdb data10 -E utf8 --locale=zh_CN.UTF-8</span><br><span class="line">vim data10/postgresql.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>Ubuntu</tag>
        <tag>initdb</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 12 变更点评</title>
    <url>/2019/10/28/postgresql-12/</url>
    <content><![CDATA[<p>PostgreSQL 12 于2019年10月3日。之前只阅读了它的<a class="link"   href="https://www.postgresql.org/about/press/presskit12/zh/#original_release" >中文概要说明<i class="fas fa-external-link-alt"></i></a><br>了解到了很多的性能提升。<br> 但在阅读<a class="link"   href="https://www.postgresql.org/docs/12/release-12.html" >完整发行说明<i class="fas fa-external-link-alt"></i></a>后，了解到了更多的有用的变更。<br> 以下挑选一些我关心的，做一下介绍。</p>
<h1 id="流复制和恢复"><a href="#流复制和恢复" class="headerlink" title="流复制和恢复"></a>流复制和恢复</h1><h2 id="废弃了recvoery-conf。"><a href="#废弃了recvoery-conf。" class="headerlink" title="废弃了recvoery.conf。"></a>废弃了<code>recvoery.conf</code>。</h2><ul>
<li>将其功能并入了<code>postgresql.conf</code>。</li>
<li>使用<code>recovery.signal</code>或<code>standby.signal</code>文件来标记当前实例的状态。</li>
<li>使用<code>promove_trigger_file</code>参数 替代了旧的 <code>trigger_file</code>参数。</li>
<li>添加<code>pg_promote()</code>函数，可以在不操作文件系统的情况下，将从库，直接升级为主库。</li>
</ul>
<h2 id="pg-basebackup-操作行为变更"><a href="#pg-basebackup-操作行为变更" class="headerlink" title="pg_basebackup 操作行为变更"></a><code>pg_basebackup</code> 操作行为变更</h2><p>使用<code>pg_basebackup -R ...</code>完成基准备份后，在备份好的数据文件夹中，没有了<code>recovery.conf</code>。<br>会多出一个<code>standby.signal</code>空文件。且在<code>postgresql.conf</code>中找不到 <code>primary_conninfo</code>项的配置。<br>此项配置会自动创建在<code>postgresql.auto.conf</code>文件中。</p>
<h1 id="默认开启JIT"><a href="#默认开启JIT" class="headerlink" title="默认开启JIT"></a>默认开启<code>JIT</code></h1><p>但在<code>FreeBSD 12.0</code>上，<code>pkg</code>包中，依旧默认选择保守地关闭了<code>JIT</code>支持。</p>
<h1 id="授权控制"><a href="#授权控制" class="headerlink" title="授权控制"></a>授权控制</h1><h1 id="支持服务端核验证书域名"><a href="#支持服务端核验证书域名" class="headerlink" title="支持服务端核验证书域名"></a>支持服务端核验证书域名</h1><p>在<code>pg_hba.conf</code>中通过配置<code>clientcert=verify-full</code>实现。这让服务器更安全！完整地实现了SSL安全传输。从源头堵住了第三方通过非法证书连接服务！</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><h2 id="btee增强"><a href="#btee增强" class="headerlink" title="btee增强"></a><code>btee</code>增强</h2><p>允许较小的多列<code>btree</code>索引，多列索引。提高了<code>btree</code>的索引性能和空间利用率。减少锁定开销，进一步提高了<code>btree</code>插入速度。</p>
<h2 id="表分区增强"><a href="#表分区增强" class="headerlink" title="表分区增强"></a>表分区增强</h2><p>更好的分表性能</p>
<h2 id="reindex-支持-concurently"><a href="#reindex-支持-concurently" class="headerlink" title="reindex 支持 concurently"></a><code>reindex</code> 支持 <code>concurently</code></h2><p>支持异步重建索引</p>
]]></content>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL BRIN索引 日志型数据索引神器</title>
    <url>/2020/06/29/postgresql-brin-index/</url>
    <content><![CDATA[<p>一张随着时间增长的表。当表的体积达到数GB或数十GB后。你会发现<code>BTREE</code>索引也也有数GB或数十GB；BTREE索引尺寸有时能达到表本身尺寸的70%左右！</p>
<p>当索引的尺寸接近或超过系统内存一半时。查询使用了索引，速度也会慢到令人无法忍受！</p>
<p>此时一般的想法是：分表！将表按不同时间段拆开。这样查询时就不需要扫描整个索引了！速度就上来了。</p>
<p>其实，此时PostgreSQL还有个更有意思的索引，简直是从根本上重新定义了这个问题！它就是：</p>
<h2 id="BRIN索引"><a href="#BRIN索引" class="headerlink" title="BRIN索引"></a><code>BRIN</code>索引</h2><p>通过<a href="http://postgres.cn/docs/12/brin-intro.html"><code>BRIN</code>索引的官方介绍</a>，得知，它的索引实现是完全另一种思路：</p>
<p><code>BRIN</code>索引，是按写入磁盘的数据块，做索引的。它记录这张表，索引字段在这个数据块上的最大值与最小值；也叫这个字段的区间。</p>
<p>这就大大减少了索引的复杂度，提高了查询速度。</p>
<p>来具体体验一下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">cashier<span class="operator">=</span><span class="operator">&gt;</span> \dt<span class="operator">+</span> log.table_name</span><br><span class="line">                           关联列表</span><br><span class="line"> 架构模式 <span class="operator">|</span>    名称    <span class="operator">|</span>  类型  <span class="operator">|</span>  拥有者  <span class="operator">|</span>  大小   <span class="operator">|</span>  描述</span><br><span class="line"><span class="comment">----------+------------+--------+----------+---------+---------</span></span><br><span class="line"> log      <span class="operator">|</span> table_name <span class="operator">|</span> 数据表 <span class="operator">|</span> postgres <span class="operator">|</span> <span class="number">6908</span> MB <span class="operator">|</span> gdb应用</span><br><span class="line">(<span class="number">1</span> 行记录)</span><br><span class="line"></span><br><span class="line">cashier<span class="operator">=</span><span class="operator">&gt;</span> \di<span class="operator">+</span> log.table_name_log_at_idx</span><br><span class="line">                                    关联列表</span><br><span class="line"> 架构模式 <span class="operator">|</span>         名称          <span class="operator">|</span> 类型 <span class="operator">|</span>  拥有者  <span class="operator">|</span>   数据表   <span class="operator">|</span>  大小  <span class="operator">|</span> 描述</span><br><span class="line"><span class="comment">----------+-----------------------+------+----------+------------+--------+------</span></span><br><span class="line"> log      <span class="operator">|</span> table_name_log_at_idx <span class="operator">|</span> 索引 <span class="operator">|</span> postgres <span class="operator">|</span> table_name <span class="operator">|</span> <span class="number">272</span> kB <span class="operator">|</span></span><br><span class="line">(<span class="number">1</span> 行记录)</span><br><span class="line"></span><br><span class="line">cashier<span class="operator">=</span><span class="operator">&gt;</span> explain analyze <span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> log.table_name <span class="keyword">where</span> log_at <span class="keyword">between</span> <span class="string">&#x27;2020-01-01 12:00:00&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-01-01 12:01:00&#x27;</span>;</span><br><span class="line">                                                                          QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Aggregate  (cost<span class="operator">=</span><span class="number">15547.84</span>.<span class="number">.15547</span><span class="number">.85</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">8</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">46.691</span>.<span class="number">.46</span><span class="number">.700</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> table_name  (cost<span class="operator">=</span><span class="number">109.06</span>.<span class="number">.15547</span><span class="number">.55</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">116</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">3.063</span>.<span class="number">.46</span><span class="number">.153</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">113</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         Recheck Cond: ((log_at <span class="operator">&gt;=</span> <span class="string">&#x27;2020-01-01 12:00:00+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone) <span class="keyword">AND</span> (log_at <span class="operator">&lt;=</span> <span class="string">&#x27;2020-01-01 12:01:00+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone))</span><br><span class="line">         <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Index Recheck: <span class="number">124960</span></span><br><span class="line">         Heap Blocks: lossy<span class="operator">=</span><span class="number">3848</span></span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> table_name_log_at_idx  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.109</span><span class="number">.03</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4059</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">1.384</span>.<span class="number">.1</span><span class="number">.389</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">39680</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">               Index Cond: ((log_at <span class="operator">&gt;=</span> <span class="string">&#x27;2020-01-01 12:00:00+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone) <span class="keyword">AND</span> (log_at <span class="operator">&lt;=</span> <span class="string">&#x27;2020-01-01 12:01:00+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone))</span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.106</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">46.797</span> ms</span><br><span class="line">(<span class="number">9</span> 行记录)</span><br><span class="line"></span><br><span class="line">cashier<span class="operator">=</span><span class="operator">&gt;</span> explain analyze <span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> log.table_name <span class="keyword">where</span> log_at <span class="keyword">between</span> <span class="string">&#x27;2020-01-01 12:00:00&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-01-01 12:01:00&#x27;</span> <span class="keyword">and</span> body_size<span class="operator">&gt;</span><span class="number">100</span>;</span><br><span class="line">                                                                          QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Aggregate  (cost<span class="operator">=</span><span class="number">15557.94</span>.<span class="number">.15557</span><span class="number">.95</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">8</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">49.396</span>.<span class="number">.49</span><span class="number">.405</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> table_name  (cost<span class="operator">=</span><span class="number">109.06</span>.<span class="number">.15557</span><span class="number">.69</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">97</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">3.574</span>.<span class="number">.48</span><span class="number">.848</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">101</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         Recheck Cond: ((log_at <span class="operator">&gt;=</span> <span class="string">&#x27;2020-01-01 12:00:00+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone) <span class="keyword">AND</span> (log_at <span class="operator">&lt;=</span> <span class="string">&#x27;2020-01-01 12:01:00+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone))</span><br><span class="line">         <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Index Recheck: <span class="number">125418</span></span><br><span class="line">         <span class="keyword">Filter</span>: (body_size <span class="operator">&gt;</span> <span class="number">100</span>)</span><br><span class="line">         <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">12</span></span><br><span class="line">         Heap Blocks: lossy<span class="operator">=</span><span class="number">3862</span></span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> table_name_log_at_idx  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.109</span><span class="number">.03</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4059</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">2.176</span>.<span class="number">.2</span><span class="number">.180</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">39680</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">               Index Cond: ((log_at <span class="operator">&gt;=</span> <span class="string">&#x27;2020-01-01 12:00:00+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone) <span class="keyword">AND</span> (log_at <span class="operator">&lt;=</span> <span class="string">&#x27;2020-01-01 12:01:00+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone))</span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.901</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">49.624</span> ms</span><br><span class="line">(<span class="number">11</span> 行记录)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可见：</p>
<ul>
<li>在一张6.9GB数据的表上，按创建时间建<code>BRIN</code>索引，建成后，索引只有272KB！</li>
<li>在做中远距离的<code>between</code>查询。只要<code>46ms</code>！</li>
<li>带时间段的多条件查询，也只要<code>49ms</code>！</li>
</ul>
]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Citus，PostgreSQL的最佳分布式改造！</title>
    <url>/2020/08/14/postgresql-citus/</url>
    <content><![CDATA[<p>对于一直工作在关系型数据库，且功能强大的PostgreSQL的开发者来说。<br>Citus 无疑是给他们插上了一对火箭！让关系型数据库的用户，也能翱翔在大数据的时代。</p>
<p>Citus 正在被很多大数据机构使用，日均更新5～10亿记录，甚至有在70个节点上，运行数据规模达1.4PB！</p>
<p>Citus 适用于多租户、实时分析场景。（这也正是我迫切需要的！）</p>
<p>下边介绍Citus的上手经历。</p>
<h1 id="试验架构"><a href="#试验架构" class="headerlink" title="试验架构"></a>试验架构</h1><pre class="mermaid">graph TB
  m[(citus0)]
  slave1[(citus1)]
  slave2[(citus2)]
  m---slave1
  m---slave2</pre>

<h1 id="准备主机"><a href="#准备主机" class="headerlink" title="准备主机"></a>准备主机</h1><p>分布式，至少两台以上主机。</p>
<ul>
<li>协调节点，负责统筹。主机名：citus0</li>
<li>工作节点，负责存储计算。主机名：citus1、citus2</li>
</ul>
<h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>在每一台机器上，按以下操作同样参数安装。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>OS：FreeBSD-12.1-RELEASE-AMD64<ul>
<li><a class="link"   href="https://www.freebsd.org/releases/12.1R/announce.html" >https://www.freebsd.org/releases/12.1R/announce.html<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
<li>PostgreSQL：12.3<ul>
<li><a class="link"   href="https://www.postgresql.org/ftp/source/v12.3/" >https://www.postgresql.org/ftp/source/v12.3/<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
<li>Citus：9.4.0<ul>
<li><a class="link"   href="https://github.com/citusdata/citus/releases/tag/v9.4.0" >https://github.com/citusdata/citus/releases/tag/v9.4.0<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
<h2 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h2><h3 id="PostgreSQL-12-3-编译"><a href="#PostgreSQL-12-3-编译" class="headerlink" title="PostgreSQL 12.3 编译"></a>PostgreSQL 12.3 编译</h3><p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kg install llvm90 gettext curl gmake</span><br><span class="line">./configure &#x27;--with-libraries=/usr/local/lib&#x27; &#x27;--with-includes=/usr/local/include&#x27; &#x27;--enable-thread-safety&#x27; &#x27;--disable-debug&#x27; &#x27;--enable-nls&#x27; &#x27;--without-pam&#x27; &#x27;--with-openssl&#x27; &#x27;--without-llvm&#x27; &#x27;--without-gssapi&#x27; &#x27;--prefix=/usr/local&#x27; &#x27;--localstatedir=/var&#x27; &#x27;--mandir=/usr/local/man&#x27; &#x27;--infodir=/usr/local/share/info/&#x27; &#x27;--build=amd64-portbld-freebsd12.1&#x27; &#x27;build_alias=amd64-portbld-freebsd12.1&#x27; &#x27;CC=cc&#x27; &#x27;CFLAGS=-O2 -pipe  -fstack-protector-strong -fno-strict-aliasing &#x27; &#x27;LDFLAGS= -L/usr/local/lib -lpthread -L/usr/local/lib  -fstack-protector-strong &#x27; &#x27;LIBS=&#x27; &#x27;CPPFLAGS=-I/usr/local/include&#x27; &#x27;CXX=c++&#x27; &#x27;CXXFLAGS=-O2 -pipe -fstack-protector-strong -fno-strict-aliasing  &#x27; &#x27;CPP=cpp&#x27; &#x27;PKG_CONFIG=pkgconf&#x27; &#x27;LDFLAGS_SL=&#x27;</span><br><span class="line">make world</span><br><span class="line">make install-world</span><br><span class="line">adduser postgres</span><br></pre></td></tr></table></figure>
<h3 id="Citus-9-4-0-编译"><a href="#Citus-9-4-0-编译" class="headerlink" title="Citus 9.4.0 编译"></a>Citus 9.4.0 编译</h3><p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure &#x27;LDFLAGS= -L/usr/local/lib -lpthread -L/usr/local/lib  -fstack-protector-strong &#x27; CPPFLAGS=-I/usr/local/include</span><br><span class="line">gmake</span><br><span class="line">gmake install</span><br></pre></td></tr></table></figure>
<h1 id="设置并启用Citus"><a href="#设置并启用Citus" class="headerlink" title="设置并启用Citus"></a>设置并启用Citus</h1><h2 id="所有主机上的共同操作"><a href="#所有主机上的共同操作" class="headerlink" title="所有主机上的共同操作"></a>所有主机上的共同操作</h2><p>注意：**<em>以下所有操作都在要每个节点主机上完整操作完。包括建库和启用<code>citus</code>。且一定是先建库，进入<code>main</code>库后再启动<code>citus</code>扩展**</em></p>
<ul>
<li>初始化数据库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su postgres</span><br><span class="line">initdb data</span><br></pre></td></tr></table></figure></li>
<li>配置<code>postgresql.conf</code><blockquote>
<p>listen_addresses = ‘*’</p>
<p>port = 5432</p>
<p>shared_buffers = 256MB # 按需调节</p>
<p>shared_preload_libraries = ‘citus’ # 关键配置</p>
</blockquote>
</li>
<li>配置<code>pg_hba.conf</code><blockquote>
<p>host    all             all             192.168.1.1/24          trust  # 开放内网访问</p>
</blockquote>
</li>
<li>启动PostgreSQL<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">pg_ctl -D data start</span><br></pre></td></tr></table></figure></li>
<li>建库并启用Citus<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">psql</span><br><span class="line">create database main;</span><br><span class="line">\c main</span><br><span class="line">create extension citus;</span><br></pre></td></tr></table></figure>
<h2 id="协调节点上的操作"><a href="#协调节点上的操作" class="headerlink" title="协调节点上的操作"></a>协调节点上的操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">psql main</span><br><span class="line">select master_add_node(&#x27;citus1&#x27;,5432);</span><br><span class="line">select master_add_node(&#x27;citus2&#x27;,5432);</span><br><span class="line"></span><br><span class="line">main=# select master_get_active_worker_nodes();</span><br><span class="line"> master_get_active_worker_nodes</span><br><span class="line">--------------------------------</span><br><span class="line"> (citus1,5432)</span><br><span class="line"> (citus2,5432)</span><br><span class="line">(2 行记录)</span><br></pre></td></tr></table></figure>
<h1 id="使用Citus"><a href="#使用Citus" class="headerlink" title="使用Citus"></a>使用Citus</h1>现在只要在协调节点<code>citus0</code>上的<code>main</code>库中建表。所有工作节点都会自动创建分表。</li>
</ul>
<p>在协调节点上存储会将数据分发到不同的工作节点上。查询也是在多个工作节点上分布查询了。</p>
]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>Citus</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 性能优化</title>
    <url>/2016/12/15/postgresql-config/</url>
    <content><![CDATA[<pre><code>PostgreSQL 一个连接一个进程，应用给WEB服务就压力山大了。
备点货以备山洪来临！</code></pre>
<p><em>以下整理自：<a class="link"   href="http://blog.gdsyzx.edu.cn/sense/?p=460#content" >Sense’s Blog<i class="fas fa-external-link-alt"></i></a></em></p>
<h1 id="服务器参数配置"><a href="#服务器参数配置" class="headerlink" title="服务器参数配置"></a>服务器参数配置</h1><p>配置文件postgres.conf中的很多设置都会影响性能，</p>
<h2 id="shared-buffers"><a href="#shared-buffers" class="headerlink" title="shared_buffers"></a>shared_buffers</h2><p>这是最重要的参数，postgresql通过shared_buffers和内核/磁盘打交道。</p>
<p>因此应该尽量大，让更多的数据缓存在shared_buffers中，通常设置为实际RAM的10％是合理的，比如50000(400M)</p>
<h2 id="work-mem"><a href="#work-mem" class="headerlink" title="work_mem"></a>work_mem</h2><p>在pgsql 8.0之前叫做sort_mem。postgresql在执行排序操作时，</p>
<p>会根据work_mem的大小决定是否将一个大的结果集拆分为几个小的和work_mem查不多大小的临时文件。</p>
<p>显然拆分的结果是降低了排序的速度。因此增加work_mem有助于提高排序的速度。通常设置为实际RAM的2%-4%，根据需要排序结果集的大小而定，比如81920(80M)</p>
<h2 id="effective-cache-size"><a href="#effective-cache-size" class="headerlink" title="effective_cache_size"></a>effective_cache_size</h2><p>是postgresql能够使用的最大缓存，<br>这个数字对于独立的pgsql服务器而言应该足够大，比如4G的内存，可以设置为3.5G(437500)</p>
<h2 id="maintence-work-mem"><a href="#maintence-work-mem" class="headerlink" title="maintence_work_mem"></a>maintence_work_mem</h2><p>这里定义的内存只是在CREATE INDEX, VACUUM等时用到，因此用到的频率不高，但是往往这些指令消耗比较多的资源，</p>
<p>因此应该尽快让这些指令快速执行完毕：给maintence_work_mem大的内存，比如512M(524288)</p>
<h2 id="max-connections"><a href="#max-connections" class="headerlink" title="max_connections"></a>max_connections</h2><p>通常，max_connections的目的是防止max_connections * work_mem超出了实际内存大小。</p>
<p>比如，如果将work_mem设置为实际内存的2%大小，则在极端情况下，如果有50个查询都有排序要求，而且都使用2％的内存，则会导致swap的产生，系统性能就会大大降低。</p>
<p>当然，如果有4G的内存，同时出现50个如此大的查询的几率应该是很小的。不过，要清楚max_connections和work_mem的关系。</p>
<p>有关参数的解释可见： <a class="link"   href="http://www.postgres.cn/docs/9.5/runtime-config.html" >http://www.postgres.cn/docs/9.5/runtime-config.html<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="硬件的选择"><a href="#硬件的选择" class="headerlink" title="硬件的选择"></a>硬件的选择</h2><p>由于计算机硬件大多数是兼容的，人们总是倾向于相信所有计算机硬件质量也是相同的。</p>
<p>事实上不是， ECC RAM（带奇偶校验的内存），SCSI （硬盘）和优质的主板比一些便宜货要更加可靠且具有更好的性能。</p>
<p>PostgreSQL几乎可以运行在任何硬件上，但如果可靠性和性能对你的系统很重要，你就需要全面的研究一下你的硬件配置了。</p>
<p>计算机硬件对性能的影响可浏览 <a class="link"   href="http://candle.pha.pa.us/main/writings/pgsql/hw_performance/index.html" >http://candle.pha.pa.us/main/writings/pgsql/hw_performance/index.html<i class="fas fa-external-link-alt"></i></a> 和 <a class="link"   href="http://www.powerpostgresql.com/PerfList/%E3%80%82" >http://www.powerpostgresql.com/PerfList/。<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="连接时收到“Sorry-too-many-clients”消息？"><a href="#连接时收到“Sorry-too-many-clients”消息？" class="headerlink" title="连接时收到“Sorry, too many clients”消息？"></a>连接时收到“Sorry, too many clients”消息？</h2><p>这表示你已达到缺省100个并发后台进程数的限制，</p>
<p>你需要通过修改postgresql.conf文件中的max_connections值来 增加postmaster的后台并发处理数，修改后需重新启动postmaster。</p>
<h1 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h1><p>检查数据检索的索引是否建立，凡是需要查找的字段尽量建立索引，甚至是联合索引；</p>
<p>创建索引，包括表达式和部分索引；</p>
<p>使用COPY语句代替多个Insert语句；</p>
<p>将多个SQL语句组成一个事务以减少提交事务的开销；</p>
<p>从一个索引中提取多条记录时使用CLUSTER；</p>
<p>从一个查询结果中取出部分记录时使用LIMIT；</p>
<p>使用预编译式查询（Prepared Query)；</p>
<p>使用ANALYZE以保持精确的优化统计；</p>
<p>定期使用 VACUUM 或 pg_autovacuum</p>
<p>进行大量数据更改时先删除索引（然后重建索引）</p>
<h1 id="程序经验"><a href="#程序经验" class="headerlink" title="程序经验"></a>程序经验</h1><p>检查程序，是否使用了连接池，如果没有使用，尽快使用吧；</p>
<p>继续检查程序，连接使用后，是否交还给了连接池；</p>
]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>使用postgresql的file-fdw扩展分析nginx日志</title>
    <url>/2019/07/10/postgresql-file-fdw-analysis-nginx-log/</url>
    <content><![CDATA[<h1 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h1><h2 id="PostgreSQL-方面"><a href="#PostgreSQL-方面" class="headerlink" title="PostgreSQL 方面"></a>PostgreSQL 方面</h2><p>PostgreSQL的file_fdw使用说明：<br><a class="link"   href="http://www.postgres.cn/docs/11/file-fdw.html" >file_fdw 中文文档<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="nginx-方面"><a href="#nginx-方面" class="headerlink" title="nginx 方面"></a>nginx 方面</h2><p>nginx 部分变量说明：</p>
<ul>
<li>$remote_addr  客户端IP</li>
<li>$time_local   读起来不太舒服的时间</li>
<li>$time_iso8601 比较舒服的时间</li>
<li>$request_time 从accept到发完相应数据，耗费的时间，单位：秒</li>
<li>$upstream_response_time   nginx收到请求交给其它应用处理并得到结果的时间，单位：秒</li>
<li>$body_bytes_sent  响应包体的尺寸，单位：字节</li>
<li>$request  请求描述</li>
<li>$status   响应的状态码</li>
</ul>
<p><strong><code>$request_time</code>、<code>$upstream_response_time</code>的记录值不一定是数字，有时会是<code>-</code></strong></p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>PostgreSQL对处理CSV比较擅长。所以我们要把nginx的日志定制成CSV的样子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_format  csv_log &#39;$remote_addr, $time_iso8601, $request_time, $upstream_response_time, $body_bytes_sent, $request, $status&#39;;</span><br></pre></td></tr></table></figure>
<p>在需要的server下应用这个格式，<strong>要确保应用后的日志文件中只有一种格式的日志</strong>。</p>
<h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><p><code>psql</code> 进入</p>
<p>判断是否安装扩展：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">\dx</span><br><span class="line">                                     List <span class="keyword">of</span> installed extensions</span><br><span class="line">        Name        <span class="operator">|</span> Version <span class="operator">|</span>   Schema   <span class="operator">|</span>                        Description</span><br><span class="line"><span class="comment">--------------------+---------+------------+-----------------------------------------------------------</span></span><br><span class="line"> file_fdw           <span class="operator">|</span> <span class="number">1.0</span>     <span class="operator">|</span> public     <span class="operator">|</span> <span class="keyword">foreign</span><span class="operator">-</span>data wrapper <span class="keyword">for</span> flat file access</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>安装扩展：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> extension file_fdw</span><br></pre></td></tr></table></figure>
<p>创建服务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SERVER nginx_log <span class="keyword">FOREIGN</span> DATA WRAPPER file_fdw;</span><br></pre></td></tr></table></figure>
<p>创建外部表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">foreign</span> <span class="keyword">table</span> app_log (</span><br><span class="line"> ip inet,</span><br><span class="line"> create_at <span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone,</span><br><span class="line"> request_cost text,</span><br><span class="line"> stream_cost text,</span><br><span class="line"> body_size <span class="type">integer</span>,</span><br><span class="line"> request text,</span><br><span class="line"> status <span class="type">integer</span></span><br><span class="line"> ) server nginx_log options ( filename <span class="string">&#x27;/your/nginx/log/path/file.log&#x27;</span>, format <span class="string">&#x27;csv&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>体验：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> client_ip,create_at,request_cost,upstream_cost,pg_size_pretty(body_size::<span class="type">bigint</span>) body_length,request <span class="keyword">from</span> app_log <span class="keyword">where</span> body_size<span class="operator">&gt;</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  client_ip  <span class="operator">|</span>       create_at        <span class="operator">|</span> request_cost <span class="operator">|</span> upstream_cost <span class="operator">|</span> body_length <span class="operator">|</span>                           request</span><br><span class="line"><span class="comment">-------------+------------------------+--------------+---------------+-------------+--------------------------------------------------------------</span></span><br><span class="line"> <span class="number">58.19</span><span class="number">.94</span><span class="number">.70</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-07</span><span class="number">-09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">37</span><span class="operator">+</span><span class="number">08</span> <span class="operator">|</span>  <span class="number">0.984</span>       <span class="operator">|</span>  <span class="number">0.113</span>        <span class="operator">|</span> <span class="number">1470</span> kB     <span class="operator">|</span>  <span class="keyword">GET</span> <span class="operator">/</span>v4<span class="number">.3</span><span class="number">.1</span><span class="operator">/</span>sync<span class="operator">/</span>member_pockets?<span class="keyword">at</span><span class="operator">=</span><span class="number">-999</span><span class="operator">&amp;</span>sid<span class="operator">=</span><span class="number">205118</span> HTTP<span class="operator">/</span><span class="number">2.0</span></span><br><span class="line"> <span class="number">58.19</span><span class="number">.94</span><span class="number">.70</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-07</span><span class="number">-09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">38</span><span class="operator">+</span><span class="number">08</span> <span class="operator">|</span>  <span class="number">0.810</span>       <span class="operator">|</span>  <span class="number">0.149</span>        <span class="operator">|</span> <span class="number">1470</span> kB     <span class="operator">|</span>  <span class="keyword">GET</span> <span class="operator">/</span>v4<span class="number">.3</span><span class="number">.1</span><span class="operator">/</span>sync<span class="operator">/</span>member_pockets?<span class="keyword">at</span><span class="operator">=</span><span class="number">-999</span><span class="operator">&amp;</span>sid<span class="operator">=</span><span class="number">205118</span> HTTP<span class="operator">/</span><span class="number">2.0</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>nginx</tag>
        <tag>file-fdw</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeBSD 上初始化 PostgreSQL 96</title>
    <url>/2017/07/12/postgresql-init/</url>
    <content><![CDATA[<h2 id="疼点"><a href="#疼点" class="headerlink" title="疼点"></a>疼点</h2><ul>
<li><code>postgres</code> 这个用户名，打起来麻烦，不及<code>pgsql</code>方便。</li>
<li><code>initdb</code> 出来的库默认是英文的</li>
</ul>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ee /etc/csh.cshrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> ll	ls -lAF</span><br><span class="line"><span class="built_in">alias</span> ls	ls -FG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setenv LANG         zh_CN.UTF-8</span><br><span class="line">setenv LC_CTYPE     zh_CN.UTF-8</span><br><span class="line">setenv LC_ALL       zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<p><code>adduser</code> pgsql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su pgsql</span><br><span class="line">initdb data96 -E utf8 --locale=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<p>注：<code>pg_upgrade -d main/ -D /var/db/postgres/data96/ -b /var/server/pgsql94/bin/ -B /usr/local/bin/ -U pgsql</code></p>
<p>这是一个成功率低、操作复杂、过程繁琐、环境要求高 的事情。</p>
<p>如果升级数据库，还是<code>pg_dump</code> <code>pg_restore</code>来得方便。</p>
<p>对于复杂关系的库，<code>pg_upgrade</code>也会出现主键丢失之类的奇怪事情。</p>
]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>FreeBSD</tag>
        <tag>initdb</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL SSL 加密传输配置</title>
    <url>/2019/10/26/postgresql-ssl/</url>
    <content><![CDATA[<h1 id="签名证书"><a href="#签名证书" class="headerlink" title="签名证书"></a>签名证书</h1><h2 id="快速测试证书"><a href="#快速测试证书" class="headerlink" title="快速测试证书"></a>快速测试证书</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -days 365 -nodes -text -out server.crt \</span><br><span class="line">  -keyout server.key -subj &quot;&#x2F;CN&#x3D;dbhost.yourdomain.com&quot;</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod og-rwx server.key</span><br></pre></td></tr></table></figure>
<h2 id="生产环境证书"><a href="#生产环境证书" class="headerlink" title="生产环境证书"></a>生产环境证书</h2><ul>
<li>创建根密钥<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -nodes -text -out root.csr \</span><br><span class="line">  -keyout root.key -subj &quot;&#x2F;CN&#x3D;root.yourdomain.com&quot;</span><br><span class="line">chmod og-rwx root.key</span><br></pre></td></tr></table></figure></li>
<li>创建根证书<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -in root.csr -text -days 3650 \</span><br><span class="line">  -extfile &#x2F;etc&#x2F;ssl&#x2F;openssl.cnf -extensions v3_ca \</span><br><span class="line">  -signkey root.key -out root.crt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的<code>-extensions v3_ca</code>中的<code>v3_ca</code> 是在 <code>/etc/ssl/openssl.cnf</code>文件中的一个配置。配置要求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ v3_ca ]</span><br><span class="line">basicConstraints &#x3D; critical,CA:TRUE</span><br><span class="line">subjectKeyIdentifier &#x3D; hash</span><br><span class="line">authorityKeyIdentifier &#x3D; keyid:always,issuer:always</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>创建服务器密钥并签名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -nodes -text -out server.csr \</span><br><span class="line">  -keyout server.key -subj &quot;&#x2F;CN&#x3D;dbhost.yourdomain.com&quot;</span><br><span class="line">chmod og-rwx server.key</span><br><span class="line"></span><br><span class="line">openssl x509 -req -in server.csr -text -days 365 \</span><br><span class="line">  -CA root.crt -CAkey root.key -CAcreateserial \</span><br><span class="line">  -out server.crt</span><br></pre></td></tr></table></figure></li>
<li>创建客户端密钥并签名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -nodes -text -out client.csr \</span><br><span class="line">  -keyout client.key -subj &quot;&#x2F;CN&#x3D;postgres&quot;</span><br><span class="line">chmod og-rwx client.key</span><br><span class="line"></span><br><span class="line">openssl x509 -req -in client.csr -text -days 365 \</span><br><span class="line">  -CA root.crt -CAkey root.key -CAcreateserial \</span><br><span class="line">  -out client.crt</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>JDBC</code> 连接时，key需要转换为der<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -inform PEM -in client.key -outform DER -nocrypt -out client.key.der</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>一张图搞定各种SQL JOINS</title>
    <url>/2017/07/22/sql-join/</url>
    <content><![CDATA[<p><img src="https://user-images.githubusercontent.com/1764005/28487907-12e08682-6ecf-11e7-9a18-1f229476f0ae.jpg"></p>
]]></content>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>SQL</tag>
        <tag>JOIN</tag>
      </tags>
  </entry>
  <entry>
    <title>swoole 编译配置</title>
    <url>/2017/06/05/swoole-configure/</url>
    <content><![CDATA[<p>./configure –enable-sockets –enable-openssl –enable-thread –enable-swoole –enable-ringbuffer –with-swoole –enable-picohttpparser –with-openssl-dir=/usr/local –with-jemalloc-dir=/usr/local</p>
<p><a class="link"   href="https://github.com/jemalloc/jemalloc" >https://github.com/jemalloc/jemalloc<i class="fas fa-external-link-alt"></i></a></p>
<p>./configure –enable-autogen  –with-jemalloc-prefix=je_</p>
<p>make -j</p>
<p>sudo make install_bin install_include install_lib</p>
<p><a class="link"   href="https://github.com/h2o/picohttpparser" >https://github.com/h2o/picohttpparser<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump 使用技巧</title>
    <url>/2020/02/05/tcpdump/</url>
    <content><![CDATA[<p>一般情况下，非HTTP协议的网络分析，在服务器端用<code>tcpdump</code>比较多，在客户端用wireshark比较多，两个抓包软件的语法是一样的。</p>
<h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><h3 id="1-1、过滤主机"><a href="#1-1、过滤主机" class="headerlink" title="1.1、过滤主机"></a>1.1、过滤主机</h3><ul>
<li>抓取所有经过eth1，目的或源地址是192.168.1.1的网络数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 host 192.168.1.1</span><br></pre></td></tr></table></figure>
<ul>
<li>指定源地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 src host 192.168.1.1</span><br></pre></td></tr></table></figure>
<ul>
<li>指定目的地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 dst host 192.168.1.1</span><br></pre></td></tr></table></figure>
<h3 id="1-2、过滤端口"><a href="#1-2、过滤端口" class="headerlink" title="1.2、过滤端口"></a>1.2、过滤端口</h3><ul>
<li>抓取所有经过eth1，目的或源端口是25的网络数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 port 25</span><br></pre></td></tr></table></figure>
<ul>
<li>指定源端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 src port 25</span><br></pre></td></tr></table></figure>
<ul>
<li>指定目的端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 dst port 25</span><br></pre></td></tr></table></figure>
<h3 id="1-3、网络过滤"><a href="#1-3、网络过滤" class="headerlink" title="1.3、网络过滤"></a>1.3、网络过滤</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 net 192.168</span><br><span class="line">tcpdump -i eth1 src net 192.168</span><br><span class="line">tcpdump -i eth1 dst net 192.168</span><br></pre></td></tr></table></figure>
<h3 id="1-4、协议过滤"><a href="#1-4、协议过滤" class="headerlink" title="1.4、协议过滤"></a>1.4、协议过滤</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 arp</span><br><span class="line">tcpdump -i eth1 ip</span><br><span class="line">tcpdump -i eth1 tcp</span><br><span class="line">tcpdump -i eth1 udp</span><br><span class="line">tcpdump -i eth1 icmp</span><br></pre></td></tr></table></figure>
<h3 id="1-5、常用表达式"><a href="#1-5、常用表达式" class="headerlink" title="1.5、常用表达式"></a>1.5、常用表达式</h3><pre><code>非 : ! or &quot;not&quot; (去掉双引号)  
且 : &amp;&amp; or &quot;and&quot;  
或 : || or &quot;or&quot;  </code></pre>
<ul>
<li>抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200端口是80的TCP数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓取所有经过eth1，目标MAC地址是00:01:02:03:04:05的ICMP数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;((icmp) and ((ether dst host 00:01:02:03:04:05)))&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓取所有经过eth1，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="二、高级包头过滤"><a href="#二、高级包头过滤" class="headerlink" title="二、高级包头过滤"></a>二、高级包头过滤</h2><p>首先了解如何从包头过滤信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（第一字节从0开始排）</span><br><span class="line">proto[x:y] &amp; z &#x3D; 0  : proto[x:y]和z的与操作为0</span><br><span class="line">proto[x:y] &amp; z !&#x3D;0  : proto[x:y]和z的与操作不为0</span><br><span class="line">proto[x:y] &amp; z &#x3D; z  : proto[x:y]和z的与操作为z</span><br><span class="line">proto[x:y] &#x3D; z      : proto[x:y]等于z</span><br></pre></td></tr></table></figure>
<p>操作符 : &gt;, &lt;, &gt;=, &lt;=, =, !=</p>
<h3 id="2-1、IP头"><a href="#2-1、IP头" class="headerlink" title="2.1、IP头"></a>2.1、IP头</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    | &lt;-- optional</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                            DATA ...                           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>本文只针对IPv4。</p>
<h3 id="2-2、Flags"><a href="#2-2、Flags" class="headerlink" title="2.2、Flags"></a>2.2、Flags</h3><table>
<thead>
<tr>
<th align="left">TCP Flag</th>
<th align="left">tcpdump Flag</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SYN</td>
<td align="left">S</td>
<td align="left">Syn数据包，会话建立请求。</td>
</tr>
<tr>
<td align="left">ACK</td>
<td align="left">A</td>
<td align="left">Ack数据包，确认发送端的数据。</td>
</tr>
<tr>
<td align="left">FIN</td>
<td align="left">F</td>
<td align="left">结束标记，终止指示。</td>
</tr>
<tr>
<td align="left">RESET</td>
<td align="left">R</td>
<td align="left">重置，指示立即终止连接。</td>
</tr>
<tr>
<td align="left">PUSH</td>
<td align="left">P</td>
<td align="left">推送，立即将缓存中的数据发完。</td>
</tr>
<tr>
<td align="left">URGENT</td>
<td align="left">U</td>
<td align="left">紧急，优先于其他数据。</td>
</tr>
<tr>
<td align="left">NONE</td>
<td align="left">.</td>
<td align="left">占位符，通常用于ACK。</td>
</tr>
</tbody></table>
<h3 id="2-3、IP选项设置了吗？"><a href="#2-3、IP选项设置了吗？" class="headerlink" title="2.3、IP选项设置了吗？"></a>2.3、IP选项设置了吗？</h3><p>“一般”的IP头是20字节，但IP头有选项设置，不能直接从偏移21字节处读取数据。IP头有个长度字段可以知道头长度是否大于20字节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>通常第一个字节的二进制值是：01000101，分成两个部分：</p>
<p>0100 = 4 表示IP版本<br>0101 = 5 表示IP头32 bit的块数，5 x 32 bits = 160 bits or 20 bytes</p>
<p>如果第一字节第二部分的值大于5，那么表示头有IP选项。</p>
<p>下面介绍两种过滤方法（第一种方法比较操蛋，可忽略）：</p>
<p>a. 比较第一字节的值是否大于01000101，这可以判断IPv4带IP选项的数据和IPv6的数据。</p>
<p>01000101十进制等于69，计算方法如下（小提示：用计算器更方便）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 : 0  \</span><br><span class="line">1 : 2^6 &#x3D; 64 \ 第一部分 (IP版本)</span><br><span class="line">0 : 0   &#x2F;</span><br><span class="line">0 : 0  &#x2F;</span><br><span class="line">-</span><br><span class="line">0 : 0  \</span><br><span class="line">1 : 2^2 &#x3D; 4  \ 第二部分 (头长度)</span><br><span class="line">0 : 0   &#x2F;</span><br><span class="line">1 : 2^0 &#x3D; 1 &#x2F;</span><br></pre></td></tr></table></figure>
<p>64 + 4 + 1 = 69</p>
<p>如果设置了IP选项，那么第一自己是01000110（十进制70），过滤规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;ip[0] &gt; 69&#x27;</span></span><br></pre></td></tr></table></figure>
<p>IPv6的数据也会匹配，看看第二种方法。</p>
<p>b. 位操作</p>
<p>0100 0101 : 第一字节的二进制<br>0000 1111 : 与操作<br>&lt;=========<br>0000 0101 : 结果  </p>
<p>正确的过滤方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;ip[0] &amp; 15 &gt; 5&#x27;</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;ip[0] &amp; 0x0f &gt; 5&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4、分片标记"><a href="#2-4、分片标记" class="headerlink" title="2.4、分片标记"></a>2.4、分片标记</h3><p>当发送端的MTU大于到目的路径链路上的MTU时就会被分片，这段话有点拗口，权威的请参考《TCP/IP详解》。唉，32借我的书没还，只能凑合写，大家记得看书啊。</p>
<p>分片信息在IP头的第七和第八字节：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>Bit 0:  保留，必须是0<br>Bit 1:  (DF) 0 = 可能分片, 1 = 不分片<br>Bit 2:  (MF) 0 = 最后的分片, 1 = 还有分片  </p>
<p>Fragment Offset字段只有在分片的时候才使用。</p>
<p>要抓带DF位标记的不分片的包，第七字节的值应该是：</p>
<p>01000000 = 64</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;ip[6] = 64&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5、抓分片包"><a href="#2-5、抓分片包" class="headerlink" title="2.5、抓分片包"></a>2.5、抓分片包</h3><ul>
<li>匹配MF，分片包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;ip[6] = 32&#x27;</span></span><br></pre></td></tr></table></figure>
<p>最后分片包的开始3位是0，但是有Fragment Offset字段。</p>
<ul>
<li>匹配分片和最后分片</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;((ip[6:2] &gt; 0) and (not ip[6] = 64))&#x27;</span></span><br></pre></td></tr></table></figure>
<p>测试分片可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping -M want -s 3000 192.168.1.1</span><br></pre></td></tr></table></figure>
<h3 id="2-6、匹配小TTL"><a href="#2-6、匹配小TTL" class="headerlink" title="2.6、匹配小TTL"></a>2.6、匹配小TTL</h3><p>TTL字段在第九字节，并且正好是完整的一个字节，TTL最大值是255，二进制为11111111。</p>
<p>可以用下面的命令验证一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping -M want -s 3000 -t 256 192.168.1.200</span><br><span class="line">ping: ttl 256 out of range</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<ul>
<li>在网关可以用下面的命令看看网络中谁在使用traceroute</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;ip[8] &lt; 5&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7、抓大于X字节的包"><a href="#2-7、抓大于X字节的包" class="headerlink" title="2.7、抓大于X字节的包"></a>2.7、抓大于X字节的包</h3><ul>
<li>大于600字节</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;ip[2:2] &gt; 600&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-8、更多的IP过滤"><a href="#2-8、更多的IP过滤" class="headerlink" title="2.8、更多的IP过滤"></a>2.8、更多的IP过滤</h3><p>首先还是需要知道TCP基本结构，再次推荐《TCP/IP详解》，卷一就够看的了，避免走火入魔。</p>
<ul>
<li>TCP头</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |       |C|E|U|A|P|R|S|F|                               |</span><br><span class="line">| Offset|  Res. |W|C|R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |       |R|E|G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<ul>
<li>抓取源端口大于1024的TCP数据包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[0:2] &gt; 1024&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>匹配TCP数据包的特殊标记</li>
</ul>
<p>TCP标记定义在TCP头的第十四个字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|C|E|U|A|P|R|S|F|</span><br><span class="line">|W|C|R|C|S|S|Y|I|</span><br><span class="line">|R|E|G|K|H|T|N|N|</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>重复一下TCP三次握手，两个主机是如何勾搭的：</p>
<ol>
<li>源发送SYN</li>
<li>目标回答SYN, ACK</li>
<li>源发送ACK</li>
</ol>
<p>没女朋友的童鞋要学习一下：  </p>
<ol>
<li>MM，你的手有空吗？-_-  </li>
<li>有空，你呢？~_~  </li>
<li>我也有空 *_*  </li>
</ol>
<p>失败的loser是酱紫的：  </p>
<ol>
<li>MM，这是你掉的板砖吗？(SYN) ￣▽￣  </li>
<li>不是，找拍啊？(RST-ACK) ˋ﹏ˊ  </li>
</ol>
<ul>
<li>只抓SYN包，第十四字节是二进制的00000010，也就是十进制的2</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[13] = 2&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓SYN, ACK （00010010 or 18）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[13] = 18&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓SYN或者SYN-ACK</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[13] &amp; 2 = 2&#x27;</span></span><br></pre></td></tr></table></figure>
<p>用到了位操作，就是不管ACK位是啥。</p>
<ul>
<li>抓PSH-ACK</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[13] = 24&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓所有包含FIN标记的包（FIN通常和ACK一起，表示幽会完了，回见）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[13] &amp; 1 = 1&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓RST（勾搭没成功，伟大的greatwall对她认为有敏感信息的连接发RST包，典型的棒打鸳鸯）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[13] &amp; 4 = 4&#x27;</span></span><br></pre></td></tr></table></figure>
<p>下图详细描述了TCP各种状态的标记，方便分析。</p>
<p><img src="https://raw.githubusercontent.com/linuxwiki/SourceWiki/master/images/tcp_state_machine.jpg" alt="tcp_state_machine.jpg"></p>
<h3 id="2-9、大叔注"><a href="#2-9、大叔注" class="headerlink" title="2.9、大叔注"></a>2.9、大叔注</h3><p>tcpdump考虑了一些数字恐惧症者的需求，提供了部分常用的字段偏移名字：</p>
<p>icmptype  (ICMP类型字段)<br>icmpcode  (ICMP符号字段)<br>tcpflags  (TCP标记字段)  </p>
<p>ICMP类型值有：</p>
<p>icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo, icmp-routeradvert, icmp-routersolicit, icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstampreply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply</p>
<p>TCP标记值：</p>
<p>tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-push, tcp-ack, tcp-urg</p>
<p>这样上面按照TCP标记位抓包的就可以写直观的表达式了：</p>
<ul>
<li>只抓SYN包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[tcpflags] = tcp-syn&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓SYN, ACK</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack != 0&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-10、抓SMTP数据"><a href="#2-10、抓SMTP数据" class="headerlink" title="2.10、抓SMTP数据"></a>2.10、抓SMTP数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;((port 25) and (tcp[(tcp[12]&gt;&gt;2):4] = 0x4d41494c))&#x27;</span></span><br></pre></td></tr></table></figure>
<p>抓取数据区开始为”MAIL”的包，”MAIL”的十六进制为0x4d41494c。</p>
<h3 id="2-11、抓HTTP-GET数据"><a href="#2-11、抓HTTP-GET数据" class="headerlink" title="2.11、抓HTTP GET数据"></a>2.11、抓HTTP GET数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[(tcp[12]&gt;&gt;2):4] = 0x47455420&#x27;</span></span><br></pre></td></tr></table></figure>
<p>“GET “的十六进制是47455420</p>
<h3 id="2-12、抓SSH返回"><a href="#2-12、抓SSH返回" class="headerlink" title="2.12、抓SSH返回"></a>2.12、抓SSH返回</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;tcp[(tcp[12]&gt;&gt;2):4] = 0x5353482D&#x27;</span></span><br></pre></td></tr></table></figure>
<p>“SSH-“的十六进制是0x5353482D</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">&#x27;(tcp[(tcp[12]&gt;&gt;2):4] = 0x5353482D) and (tcp[((tcp[12]&gt;&gt;2)+4):2] = 0x312E)&#x27;</span></span><br></pre></td></tr></table></figure>
<p>抓老版本的SSH返回信息，如”SSH-1.99..”</p>
<h2 id="三、大叔注"><a href="#三、大叔注" class="headerlink" title="三、大叔注"></a>三、大叔注</h2><p>如果是为了查看数据内容，建议用<code>tcpdump -s 0 -w filename</code>把数据包都保存下来，然后用wireshark的Follow TCP Stream/Follow UDP Stream来查看整个会话的内容。</p>
<p><code>-s 0</code>是抓取完整数据包，否则默认只抓68字节。</p>
<p>另外，用tcpflow也可以方便的获取TCP会话内容，支持tcpdump的各种表达式。</p>
<h3 id="3-1、UDP头"><a href="#3-1、UDP头" class="headerlink" title="3.1、UDP头"></a>3.1、UDP头</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0      7 8     15 16    23 24    31</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|     Source      |   Destination   |</span><br><span class="line">|      Port       |      Port       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|     Length      |    Checksum     |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|                                   |</span><br><span class="line">|              DATA ...             |</span><br><span class="line">+-----------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>抓DNS请求数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 udp dst port 53</span><br></pre></td></tr></table></figure>
<h3 id="3-2、其他"><a href="#3-2、其他" class="headerlink" title="3.2、其他"></a>3.2、其他</h3><p><code>-c</code>参数对于运维人员来说也比较常用，因为流量比较大的服务器，靠人工CTRL+C还是抓的太多，甚至导致服务器宕机，于是可以用<code>-c</code>参数指定抓多少个包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time tcpdump -nn -i eth0 <span class="string">&#x27;tcp[tcpflags] = tcp-syn&#x27;</span> -c 10000 &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>上面的命令计算抓10000个SYN包花费多少时间，可以判断访问量大概是多少。</p>
<h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><blockquote>
<p><a class="link"   href="http://www.wains.be/pub/networking/tcpdump_advanced_filters.txt" >tcpdump advanced filters<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <tags>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯与华为到低谁更赚钱</title>
    <url>/2019/07/30/tencent-vs-huwwei-2019/</url>
    <content><![CDATA[<p>今天华为发布2019年上半年业绩，收入同比增长23.2%！那么华为今年上半年卖了多少钱呢？</p>
<p><strong>4013亿人民币/6个月</strong></p>
<p>腾讯2019年5月15日公布的一季度财报显示，腾讯卖了854.65亿。二季度还没出来，且简单做x2推算吧。</p>
<p><strong>1708亿人民币/6个月</strong></p>
<p>腾讯一软件服务公司，收钱的能力连卖货的华为一半都不到。不过得深挖一下。</p>
<pre class="mermaid">pie title 营收
  "华为" : 4013
  "腾讯" : 1708</pre>


<h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><blockquote>
<p>[中国，深圳，2019年7月30日] 2019年上半年，华为实现销售收入4013亿人民币，<br>同比增长23.2%，<u>净利润率8.7%</u>。<a class="link"   href="https://www.huawei.com/cn/press-events/news/2019/7/huawei-announces-h1-2019-revenue" >源自：官方新闻<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>华为净利润：4013 x 0.087 / 6 = <strong>58.1亿/月</strong></p>
<h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><blockquote>
<p>期内盈利为人民币 278.56 亿元（41.37 亿美元），比去年同期增长 16%；<u>净利润率与去年同期持平，为<br>  33%</u>。<a class="link"   href="http://www.tencent.com/zh-cn/articles/15000771557911821.pdf" >源自：官方财报<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>腾讯净利润：854.65 x 0.33 / 3 = <strong>94亿/月</strong></p>
<pre class="mermaid">pie title 净利润
  "华为" : 58.1
  "腾讯" : 94</pre>

<h3 id="还是搞软件服务更赚钱啊！～～～"><a href="#还是搞软件服务更赚钱啊！～～～" class="headerlink" title="还是搞软件服务更赚钱啊！～～～"></a>还是搞软件服务更赚钱啊！～～～</h3>]]></content>
      <tags>
        <tag>财报解读</tag>
      </tags>
  </entry>
  <entry>
    <title>truss lsof strace ltrace 让你知道系统运行中的进程正在干什么</title>
    <url>/2017/06/12/truss-lsof-strace-ltrace/</url>
    <content><![CDATA[<p>#truss<br>这个命令一般UNIX平台自带。使用举例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[bluse@ybcz ~/vhosts/bluse]$ sudo truss -p48932</span><br><span class="line">clock_gettime(4,&#123;334689.597960013 &#125;)		 = 0 (0x0)</span><br><span class="line">clock_gettime(4,&#123;334689.598165067 &#125;)		 = 0 (0x0)</span><br><span class="line">clock_gettime(4,&#123;334689.598310337 &#125;)		 = 0 (0x0)</span><br><span class="line">gettimeofday(&#123;1480832080.977889 &#125;,0x0)		 = 0 (0x0)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,54) = 54 (0x36)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,52) = 52 (0x34)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,56) = 56 (0x38)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,55) = 55 (0x37)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,50) = 50 (0x32)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,55) = 55 (0x37)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,54) = 54 (0x36)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,47) = 47 (0x2f)</span><br><span class="line">clock_gettime(4,&#123;334689.600967100 &#125;)		 = 0 (0x0)</span><br><span class="line">gettimeofday(&#123;1480832080.980523 &#125;,0x0)		 = 0 (0x0)</span><br><span class="line">gettimeofday(&#123;1480832080.980791 &#125;,0x0)		 = 0 (0x0)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,52) = 52 (0x34)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,50) = 50 (0x32)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,49) = 49 (0x31)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,46) = 46 (0x2e)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,45) = 45 (0x2d)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,49) = 49 (0x31)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,46) = 46 (0x2e)</span><br><span class="line">write(14,&quot;*3\r\n$4\r\nhget\r\n$14\r\nstate&quot;...,46) = 46 (0x2e)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是实时查看。也可以：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">truss -p 48932 -o out.truss</span><br></pre></td></tr></table></figure>
<p>把结果输出至文件中。捕获一断时间后再细分析。</p>
<p>这个命令能让你很方便地看清异常位置。如：死循环、某些未写入日志的异常等。</p>
<p>很适合用来解决CPU占用过高、难定位的异常、难重现的异常等 。</p>
<p>#lsof<br>这个linux/unix都好使。它有两个方面好使。</p>
<ul>
<li>按端口查连接<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bluse@bluse-Inspiron-1427:~/www/vhost$ lsof -i:80</span><br><span class="line">COMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">cairo-doc 3059 bluse   24u  IPv4  95707      0t0  TCP 192.168.1.102:40728-&gt;ec2-35-162-44-96.us-west-2.compute.amazonaws.com:http (ESTABLISHED)</span><br><span class="line">xmradio   3425 bluse   13u  IPv4  96506      0t0  TCP 192.168.1.102:48640-&gt;202.108.249.250:http (ESTABLISHED)</span><br><span class="line">xmradio   3425 bluse   14u  IPv4  90643      0t0  TCP 192.168.1.102:57590-&gt;140.205.220.98:http (CLOSE_WAIT)</span><br><span class="line">gvfsd-htt 3450 bluse   10u  IPv4  95783      0t0  TCP 192.168.1.102:55522-&gt;123.125.7.240:http (ESTABLISHED)</span><br><span class="line">chrome    3967 bluse  162u  IPv4  95526      0t0  TCP 192.168.1.102:58632-&gt;128.199.228.91:http (ESTABLISHED)</span><br><span class="line">chrome    3967 bluse  202u  IPv4  95527      0t0  TCP 192.168.1.102:58634-&gt;128.199.228.91:http (ESTABLISHED)</span><br><span class="line">chrome    3967 bluse  228u  IPv4  91831      0t0  TCP 192.168.1.102:58714-&gt;151.101.52.249:http (ESTABLISHED)</span><br></pre></td></tr></table></figure></li>
<li>按进程PID查文件调用<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bluse@bluse-Inspiron-1427:~/www/vhost$ lsof -p 3425</span><br><span class="line">COMMAND  PID  USER   FD      TYPE             DEVICE SIZE/OFF     NODE NAME</span><br><span class="line">xmradio 3425 bluse  cwd       DIR                8,1     4096   262146 /home/bluse</span><br><span class="line">xmradio 3425 bluse  rtd       DIR                8,1     4096        2 /</span><br><span class="line">xmradio 3425 bluse  txt       REG                8,1    14664 21375342 /usr/bin/xmradio</span><br><span class="line">xmradio 3425 bluse  mem       REG               0,19 67108904       15 /dev/shm/pulse-shm-1137957205</span><br><span class="line">xmradio 3425 bluse  mem       REG                8,1    10256 21435409 /usr/lib/vlc/plugins/audio_filter/libtrivial_channel_mixer_plugin.so</span><br><span class="line">xmradio 3425 bluse  mem       REG                8,1    34920 21435412 /usr/lib/vlc/plugins/audio_filter/libaudio_format_plugin.so</span><br><span class="line">xmradio 3425 bluse  mem       REG                8,1    10272 21435429 /usr/lib/vlc/plugins/audio_filter/libugly_resampler_plugin.so</span><br><span class="line">xmradio 3425 bluse  mem       REG                8,1    10280 21435410 /usr/lib/vlc/plugins/audio_filter/libdolby_surround_decoder_plugin.so</span><br><span class="line">xmradio 3425 bluse  mem       REG                8,1    10320 21435419 /usr/lib/vlc/plugins/audio_filter/libdtstospdif_plugin.so</span><br><span class="line">xmradio 3425 bluse  mem       REG                8,1    18472 21435431 /usr/lib/vlc/plugins/audio_filter/libsimple_channel_mixer_plugin.so</span><br><span class="line">xmradio 3425 bluse  mem       REG                8,1     6176 21435428 /usr/lib/vlc/plugins/audio_filter/liba52tospdif_plugin.so</span><br><span class="line">xmradio 3425 bluse  mem       REG               0,19 67108904        7 /dev/shm/pulse-shm-3282743321</span><br><span class="line">xmradio 3425 bluse  mem       REG                8,1  4343844 22414964 /usr/share/fonts/truetype/nanum/NanumGothic.ttf</span><br></pre></td></tr></table></figure>
#strace<br>它的用法也差不多：<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">strace -f -o vim.strace vim： 跟踪vim及其子进程的运行，将输出信息写到文件vim.strace。</span><br></pre></td></tr></table></figure>
进程调试<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bluse@bluse-Inspiron-1427:~/www/vhost$ sudo strace -o out.strace lsof -p 3425</span><br><span class="line">bluse@bluse-Inspiron-1427:~/www/vhost$ head -10 out.strace </span><br><span class="line">execve(&quot;/usr/bin/lsof&quot;, [&quot;lsof&quot;, &quot;-p&quot;, &quot;3425&quot;], [/* 26 vars */]) = 0</span><br><span class="line">brk(NULL)                               = 0x562c9956b000</span><br><span class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29b0751000</span><br><span class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=188234, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 188234, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f29b0723000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
##htop 中使用 strace<br>htop中内置了strace</li>
</ul>
<p>进入<code>htop</code>后按上下方向键选择进程，在需要调试的进程上按<code>s</code>就能进入 它的strace。<code>F8</code>是自动翻页开关！</p>
<p>#ltrace</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo ltrace -p 3425</span><br><span class="line">--- UNKNOWN_SIGNAL (Unknown signal 32) ---</span><br><span class="line">+++ exited (status 0) +++</span><br><span class="line">+++ exited (status 0) +++</span><br><span class="line">+++ exited (status 0) +++</span><br><span class="line">--- SIGCHLD (Child exited) ---</span><br></pre></td></tr></table></figure>
<p>作为系统管理，以上这些用法基本能满足日常所需。更多深度功能得找各自的<code>man</code></p>
]]></content>
      <tags>
        <tag>FreeBSD</tag>
        <tag>运维</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 webpack 打包 font-awesome</title>
    <url>/2017/02/21/webpack-font-awesome/</url>
    <content><![CDATA[<p>当 <code>npm install font-awesome --save</code> 后在主scss文件中：<br><code>@import ~font-awesome</code> 会报很多问题</p>
<p>问题主要是两方面：</p>
<ul>
<li>路径</li>
<li>加载器</li>
</ul>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">@import &quot;~font-awesome/scss/variables&quot;;</span><br><span class="line">$fa-font-path: &quot;~font-awesome/fonts&quot;;</span><br><span class="line">@import &quot;~font-awesome/scss/font-awesome&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;test: /\.eot(\?v=\d+.\d+.\d+)?$/, loader: &#x27;file-loader&#x27;&#125;,</span><br><span class="line">    &#123;test: /\.woff(2)?(\?v=[0-9]\.[0-9]\.[0-9])?$/, loader: &#x27;url-loader?limit=10000&amp;mimetype=application/font-woff&#x27;&#125;,</span><br><span class="line">    &#123;test: /\.(ttf|eot|svg)(\?v=[0-9]\.[0-9]\.[0-9])?$/, loader: &quot;file-loader?limit=10000&quot;&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>font-awesome</tag>
      </tags>
  </entry>
  <entry>
    <title>电子商务法</title>
    <url>/2021/01/07/electronic-commerce-law/</url>
    <content><![CDATA[<h1 id="中华人民共和国电子商务法"><a href="#中华人民共和国电子商务法" class="headerlink" title="中华人民共和国电子商务法"></a>中华人民共和国电子商务法</h1><h2 id="第一章-总-则"><a href="#第一章-总-则" class="headerlink" title="第一章 总 则"></a>第一章 总 则</h2><h4 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h4><p>为了保障电子商务各方主体的合法权益，规范电子商务行为，维护市场秩序，促进电子商务持续健康发展，制定本法。</p>
<h4 id="第二条"><a href="#第二条" class="headerlink" title="第二条"></a>第二条</h4><p>中华人民共和国境内的电子商务活动，适用本法。</p>
<p> 本法所称电子商务，是指通过互联网等信息网络销售商品或者提供服务的经营活 动。</p>
<p> 法律、行政法规对销售商品或者提供服务有规定的，适用其规定。金融类产品和 服务，利用信息网络提供新闻信息、音视频节目、出版以及文化产品等内容方面的服 务，不适用本法。</p>
<h4 id="第三条"><a href="#第三条" class="headerlink" title="第三条"></a>第三条</h4><p>国家鼓励发展电子商务新业态，创新商业模式，促进电子商务技术研发 和推广应用，推进电子商务诚信体系建设，营造有利于电子商务创新发展的市场环境， 充分发挥电子商务在推动高质量发展、满足人民日益增长的美好生活需要、构建开放 型经济方面的重要作用。</p>
<h3 id="第四条"><a href="#第四条" class="headerlink" title="第四条"></a>第四条</h3><p>国家平等对待线上线下商务活动，促进线上线下融合发展，各级人民政府和有关部门不得采取歧视性的政策措施，不得滥用行政权力排除、限制市场竞争。</p>
<h4 id="第五条"><a href="#第五条" class="headerlink" title="第五条"></a>第五条</h4><p>电子商务经营者从事经营活动，应当遵循自愿、平等、公平、诚信的原则，遵守法律和商业道德，公平参与市场竞争，履行消费者权益保护、环境保护、知识产权保护、网络安全与个人信息保护等方面的义务，承担产品和服务质量责任，接受政府和社会的监督。</p>
<h4 id="第六条"><a href="#第六条" class="headerlink" title="第六条"></a>第六条</h4><p>国务院有关部门按照职责分工负责电子商务发展促进、监督管理等工作。县级以上地方各级人民政府可以根据本行政区域的实际情况，确定本行政区域内电子商务的部门职责划分。</p>
<h4 id="第七条"><a href="#第七条" class="headerlink" title="第七条"></a>第七条</h4><p>国家建立符合电子商务特点的协同管理体系，推动形成有关部门、电子商务行业组织、电子商务经营者、消费者等共同参与的电子商务市场治理体系。</p>
<h4 id="第八条"><a href="#第八条" class="headerlink" title="第八条"></a>第八条</h4><p>电子商务行业组织按照本组织章程开展行业自律，建立健全行业规范，推动行业诚信建设，监督、引导本行业经营者公平参与市场竞争。</p>
<h2 id="第二章-电子商务经营者"><a href="#第二章-电子商务经营者" class="headerlink" title="第二章 电子商务经营者"></a>第二章 电子商务经营者</h2><h3 id="第一节-一般规定"><a href="#第一节-一般规定" class="headerlink" title="第一节 一般规定"></a>第一节 一般规定</h3><h4 id="第九条"><a href="#第九条" class="headerlink" title="第九条"></a>第九条</h4><p>本法所称电子商务经营者，是指通过互联网等信息网络从事销售商品或者提供服务的经营活动的自然人、法人和非法人组织，包括电子商务平台经营者、平台内经营者以及通过自建网站、其他网络服务销售商品或者提供服务的电子商务经营者。</p>
<p> 本法所称电子商务平台经营者，是指在电子商务中为交易双方或者多方提供网络经营场所、交易撮合、信息发布等服务，供交易双方或者多方独立开展交易活动的法人或者非法人组织。</p>
<p> 本法所称平台内经营者，是指通过电子商务平台销售商品或者提供服务的电子商务经营者。</p>
<h4 id="第十条"><a href="#第十条" class="headerlink" title="第十条"></a>第十条</h4><p>电子商务经营者应当依法办理市场主体登记。但是，个人销售自产农副产品、家庭手工业产品，个人利用自己的技能从事依法无须取得许可的便民劳务活动和零星小额交易活动，以及依照法律、行政法规不需要进行登记的除外。</p>
<h4 id="第十一条"><a href="#第十一条" class="headerlink" title="第十一条"></a>第十一条</h4><p>电子商务经营者应当依法履行纳税义务，并依法享受税收优惠。</p>
<p> 依照前条规定不需要办理市场主体登记的电子商务经营者在首次纳税义务发生后，应当依照税收征收管理法律、行政法规的规定申请办理税务登记，并如实申报纳税。</p>
<h4 id="第十二条"><a href="#第十二条" class="headerlink" title="第十二条"></a>第十二条</h4><p>电子商务经营者从事经营活动，依法需要取得相关行政许可的，应当依法取得行政许可。</p>
<h4 id="第十三条"><a href="#第十三条" class="headerlink" title="第十三条"></a>第十三条</h4><p>电子商务经营者销售的商品或者提供的服务应当符合保障人身、财产安全的要求和环境保护要求，不得销售或者提供法律、行政法规禁止交易的商品或者服务。</p>
<h4 id="第十四条"><a href="#第十四条" class="headerlink" title="第十四条"></a>第十四条</h4><p>电子商务经营者销售商品或者提供服务应当依法出具纸质发票或者电子发票等购货凭证或者服务单据。电子发票与纸质发票具有同等法律效力。</p>
<h4 id="第十五条"><a href="#第十五条" class="headerlink" title="第十五条"></a>第十五条</h4><p>电子商务经营者应当在其首页显著位置，持续公示营业执照信息、与其经营业务有关的行政许可信息、属于依照本法第十条规定的不需要办理市场主体登记情形等信息，或者上述信息的链接标识。</p>
<p> 前款规定的信息发生变更的，电子商务经营者应当及时更新公示信息。</p>
<h4 id="第十六条"><a href="#第十六条" class="headerlink" title="第十六条"></a>第十六条</h4><p>电子商务经营者自行终止从事电子商务的，应当提前三十日在首页显著位置持续公示有关信息。</p>
<h4 id="第十七条"><a href="#第十七条" class="headerlink" title="第十七条"></a>第十七条</h4><p>电子商务经营者应当全面、真实、准确、及时地披露商品或者服务信息，保障消费者的知情权和选择权。电子商务经营者不得以虚构交易、编造用户评价等方式进行虚假或者引人误解的商业宣传，欺骗、误导消费者。</p>
<h4 id="第十八条"><a href="#第十八条" class="headerlink" title="第十八条"></a>第十八条</h4><p>电子商务经营者根据消费者的兴趣爱好、消费习惯等特征向其提供商品或者服务的搜索结果的，应当同时向该消费者提供不针对其个人特征的选项，尊重<br>和平等保护消费者合法权益。</p>
<p> 电子商务经营者向消费者发送广告的，应当遵守《中华人民共和国广告法》的有关规定。</p>
<h4 id="第十九条"><a href="#第十九条" class="headerlink" title="第十九条"></a>第十九条</h4><p>电子商务经营者搭售商品或者服务，应当以显著方式提请消费者注意，不得将搭售商品或者服务作为默认同意的选项。</p>
<h4 id="第二十条"><a href="#第二十条" class="headerlink" title="第二十条"></a>第二十条</h4><p>电子商务经营者应当按照承诺或者与消费者约定的方式、时限向消费者交付商品或者服务，并承担商品运输中的风险和责任。但是，消费者另行选择快递物流服务提供者的除外。</p>
<h4 id="第二十一条"><a href="#第二十一条" class="headerlink" title="第二十一条"></a>第二十一条</h4><p>电子商务经营者按照约定向消费者收取押金的，应当明示押金退还的方式、程序，不得对押金退还设置不合理条件。消费者申请退还押金，符合押金退还条件的，电子商务经营者应当及时退还。</p>
<h4 id="第二十二条"><a href="#第二十二条" class="headerlink" title="第二十二条"></a>第二十二条</h4><p>电子商务经营者因其技术优势、用户数量、对相关行业的控制能力以及其他经营者对该电子商务经营者在交易上的依赖程度等因素而具有市场支配地位的，不得滥用市场支配地位，排除、限制竞争。</p>
<h4 id="第二十三条"><a href="#第二十三条" class="headerlink" title="第二十三条"></a>第二十三条</h4><p>电子商务经营者收集、使用其用户的个人信息，应当遵守法律、行政法规有关个人信息保护的规定。</p>
<h4 id="第二十四条"><a href="#第二十四条" class="headerlink" title="第二十四条"></a>第二十四条</h4><p>电子商务经营者应当明示用户信息查询、更正、删除以及用户注销的方式、程序，不得对用户信息查询、更正、删除以及用户注销设置不合理条件。</p>
<p> 电子商务经营者收到用户信息查询或者更正、删除的申请的，应当在核实身份后及时提供查询或者更正、删除用户信息。用户注销的，电子商务经营者应当立即删除该用户的信息；依照法律、行政法规的规定或者双方约定保存的，依照其规定。</p>
<h4 id="第二十五条"><a href="#第二十五条" class="headerlink" title="第二十五条"></a>第二十五条</h4><p>有关主管部门依照法律、行政法规的规定要求电子商务经营者提供有关电子商务数据信息的，电子商务经营者应当提供。有关主管部门应当采取必要措施保护电子商务经营者提供的数据信息的安全，并对其中的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。</p>
<h4 id="第二十六条"><a href="#第二十六条" class="headerlink" title="第二十六条"></a>第二十六条</h4><p>电子商务经营者从事跨境电子商务，应当遵守进出口监督管理的法律、行政法规和国家有关规定。</p>
<h3 id="第二节-电子商务平台经营者"><a href="#第二节-电子商务平台经营者" class="headerlink" title="第二节 电子商务平台经营者"></a>第二节 电子商务平台经营者</h3><h4 id="第二十七条"><a href="#第二十七条" class="headerlink" title="第二十七条"></a>第二十七条</h4><p>电子商务平台经营者应当要求申请进入平台销售商品或者提供服务的经营者提交其身份、地址、联系方式、行政许可等真实信息，进行核验、登记，建立登记档案，并定期核验更新。</p>
<p> 电子商务平台经营者为进入平台销售商品或者提供服务的非经营用户提供服务，应当遵守本节有关规定。</p>
<h4 id="第二十八条"><a href="#第二十八条" class="headerlink" title="第二十八条"></a>第二十八条</h4><p>电子商务平台经营者应当按照规定向市场监督管理部门报送平台内经营者的身份信息，提示未办理市场主体登记的经营者依法办理登记，并配合市场监督管理部门，针对电子商务的特点，为应当办理市场主体登记的经营者办理登记提供便利。</p>
<p> 电子商务平台经营者应当依照税收征收管理法律、行政法规的规定，向税务部门报送平台内经营者的身份信息和与纳税有关的信息，并应当提示依照本法第十条规定不需要办理市场主体登记的电子商务经营者依照本法第十一条第二款的规定办理税务登记。</p>
<h4 id="第二十九条"><a href="#第二十九条" class="headerlink" title="第二十九条"></a>第二十九条</h4><p>电子商务平台经营者发现平台内的商品或者服务信息存在违反本法第十二条、第十三条规定情形的，应当依法采取必要的处置措施，并向有关主管部门报告。</p>
<h4 id="第三十条"><a href="#第三十条" class="headerlink" title="第三十条"></a>第三十条</h4><p>电子商务平台经营者应当采取技术措施和其他必要措施保证其网络安全、稳定运行，防范网络违法犯罪活动，有效应对网络安全事件，保障电子商务交易安全。</p>
<p> 电子商务平台经营者应当制定网络安全事件应急预案，发生网络安全事件时，应当立即启动应急预案，采取相应的补救措施，并向有关主管部门报告。</p>
<h4 id="第三十一条"><a href="#第三十一条" class="headerlink" title="第三十一条"></a>第三十一条</h4><p>电子商务平台经营者应当记录、保存平台上发布的商品和服务信息、交易信息，并确保信息的完整性、保密性、可用性。商品和服务信息、交易信息保存时间自交易完成之日起不少于三年；法律、行政法规另有规定的，依照其规定。</p>
<h4 id="第三十二条"><a href="#第三十二条" class="headerlink" title="第三十二条"></a>第三十二条</h4><p>电子商务平台经营者应当遵循公开、公平、公正的原则，制定平台服务协议和交易规则，明确进入和退出平台、商品和服务质量保障、消费者权益保护、个人信息保护等方面的权利和义务。</p>
<h4 id="第三十三条"><a href="#第三十三条" class="headerlink" title="第三十三条"></a>第三十三条</h4><p>电子商务平台经营者应当在其首页显著位置持续公示平台服务协议和交易规则信息或者上述信息的链接标识，并保证经营者和消费者能够便利、完整地阅览和下载。</p>
<h4 id="第三十四条"><a href="#第三十四条" class="headerlink" title="第三十四条"></a>第三十四条</h4><p>电子商务平台经营者修改平台服务协议和交易规则，应当在其首页显著位置公开征求意见，采取合理措施确保有关各方能够及时充分表达意见。修改内容应当至少在实施前七日予以公示。</p>
<p> 平台内经营者不接受修改内容，要求退出平台的，电子商务平台经营者不得阻止，并按照修改前的服务协议和交易规则承担相关责任。</p>
<h4 id="第三十五条"><a href="#第三十五条" class="headerlink" title="第三十五条"></a>第三十五条</h4><p>电子商务平台经营者不得利用服务协议、交易规则以及技术等手段，对平台内经营者在平台内的交易、交易价格以及与其他经营者的交易等进行不合理限制或者附加不合理条件，或者向平台内经营者收取不合理费用。</p>
<h4 id="第三十六条"><a href="#第三十六条" class="headerlink" title="第三十六条"></a>第三十六条</h4><p>电子商务平台经营者依据平台服务协议和交易规则对平台内经营者违反法律、法规的行为实施警示、暂停或者终止服务等措施的，应当及时公示。</p>
<h4 id="第三十七条"><a href="#第三十七条" class="headerlink" title="第三十七条"></a>第三十七条</h4><p>电子商务平台经营者在其平台上开展自营业务的，应当以显著方式区分标记自营业务和平台内经营者开展的业务，不得误导消费者。</p>
<p> 电子商务平台经营者对其标记为自营的业务依法承担商品销售者或者服务提供者的民事责任。</p>
<h4 id="第三十八条"><a href="#第三十八条" class="headerlink" title="第三十八条"></a>第三十八条</h4><p>电子商务平台经营者知道或者应当知道平台内经营者销售的商品或者提供的服务不符合保障人身、财产安全的要求，或者有其他侵害消费者合法权益行为，未采取必要措施的，依法与该平台内经营者承担连带责任。</p>
<p> 对关系消费者生命健康的商品或者服务，电子商务平台经营者对平台内经营者的资质资格未尽到审核义务，或者对消费者未尽到安全保障义务，造成消费者损害的，依法承担相应的责任。</p>
<h4 id="第三十九条"><a href="#第三十九条" class="headerlink" title="第三十九条"></a>第三十九条</h4><p>电子商务平台经营者应当建立健全信用评价制度，公示信用评价规则，为消费者提供对平台内销售的商品或者提供的服务进行评价的途径。</p>
<p> 电子商务平台经营者不得删除消费者对其平台内销售的商品或者提供的服务的评价。</p>
<h4 id="第四十条"><a href="#第四十条" class="headerlink" title="第四十条"></a>第四十条</h4><p>电子商务平台经营者应当根据商品或者服务的价格、销量、信用等以多种方式向消费者显示商品或者服务的搜索结果；对于竞价排名的商品或者服务，应当显著标明“广告”。</p>
<h4 id="第四十一条"><a href="#第四十一条" class="headerlink" title="第四十一条"></a>第四十一条</h4><p>电子商务平台经营者应当建立知识产权保护规则，与知识产权权利人加强合作，依法保护知识产权。</p>
<h4 id="第四十二条"><a href="#第四十二条" class="headerlink" title="第四十二条"></a>第四十二条</h4><p>知识产权权利人认为其知识产权受到侵害的，有权通知电子商务平台经营者采取删除、屏蔽、断开链接、终止交易和服务等必要措施。通知应当包括构成侵权的初步证据。</p>
<p> 电子商务平台经营者接到通知后，应当及时采取必要措施，并将该通知转送平台内经营者；未及时采取必要措施的，对损害的扩大部分与平台内经营者承担连带责任。</p>
<p> 因通知错误造成平台内经营者损害的，依法承担民事责任。恶意发出错误通知，造成平台内经营者损失的，加倍承担赔偿责任。</p>
<h4 id="第四十三条"><a href="#第四十三条" class="headerlink" title="第四十三条"></a>第四十三条</h4><p>平台内经营者接到转送的通知后，可以向电子商务平台经营者提交不存在侵权行为的声明。声明应当包括不存在侵权行为的初步证据。</p>
<p> 电子商务平台经营者接到声明后，应当将该声明转送发出通知的知识产权权利人，并告知其可以向有关主管部门投诉或者向人民法院起诉。电子商务平台经营者在转送声明到达知识产权权利人后十五日内，未收到权利人已经投诉或者起诉通知的，应当及时终止所采取的措施。</p>
<h4 id="第四十四条"><a href="#第四十四条" class="headerlink" title="第四十四条"></a>第四十四条</h4><p>电子商务平台经营者应当及时公示收到的本法第四十二条、第四十三条规定的通知、声明及处理结果。</p>
<h4 id="第四十五条"><a href="#第四十五条" class="headerlink" title="第四十五条"></a>第四十五条</h4><p>电子商务平台经营者知道或者应当知道平台内经营者侵犯知识产权的，应当采取删除、屏蔽、断开链接、终止交易和服务等必要措施；未采取必要措施的，与侵权人承担连带责任。</p>
<h4 id="第四十六条"><a href="#第四十六条" class="headerlink" title="第四十六条"></a>第四十六条</h4><p>除本法第九条第二款规定的服务外，电子商务平台经营者可以按照平台服务协议和交易规则，为经营者之间的电子商务提供仓储、物流、支付结算、交收等服务。电子商务平台经营者为经营者之间的电子商务提供服务，应当遵守法律、行政法规和国家有关规定，不得采取集中竞价、做市商等集中交易方式进行交易，不得进行标准化合约交易。</p>
<h2 id="第三章-电子商务合同的订立与履行"><a href="#第三章-电子商务合同的订立与履行" class="headerlink" title="第三章 电子商务合同的订立与履行"></a>第三章 电子商务合同的订立与履行</h2><h4 id="第四十七条"><a href="#第四十七条" class="headerlink" title="第四十七条"></a>第四十七条</h4><p>电子商务当事人订立和履行合同，适用本章和《中华人民共和国民法总则》《中华人民共和国合同法》《中华人民共和国电子签名法》等法律的规定。</p>
<h4 id="第四十八条"><a href="#第四十八条" class="headerlink" title="第四十八条"></a>第四十八条</h4><p>电子商务当事人使用自动信息系统订立或者履行合同的行为对使用该系统的当事人具有法律效力。</p>
<p>在电子商务中推定当事人具有相应的民事行为能力。但是，有相反证据足以推翻的除外。</p>
<h4 id="第四十九条"><a href="#第四十九条" class="headerlink" title="第四十九条"></a>第四十九条</h4><p>电子商务经营者发布的商品或者服务信息符合要约条件的，用户选择该商品或者服务并提交订单成功，合同成立。当事人另有约定的，从其约定。电子商务经营者不得以格式条款等方式约定消费者支付价款后合同不成立；格式条款等含有该内容的，其内容无效。</p>
<h4 id="第五十条"><a href="#第五十条" class="headerlink" title="第五十条"></a>第五十条</h4><p>电子商务经营者应当清晰、全面、明确地告知用户订立合同的步骤、注意事项、下载方法等事项，并保证用户能够便利、完整地阅览和下载。电子商务经营者应当保证用户在提交订单前可以更正输入错误。</p>
<h4 id="第五十一条"><a href="#第五十一条" class="headerlink" title="第五十一条"></a>第五十一条</h4><p>合同标的为交付商品并采用快递物流方式交付的，收货人签收时间为交付时间。合同标的为提供服务的，生成的电子凭证或者实物凭证中载明的时间为交付时间；前述凭证没有载明时间或者载明时间与实际提供服务时间不一致的，实际提供服务的时间为交付时间。</p>
<p>合同标的为采用在线传输方式交付的，合同标的进入对方当事人指定的特定系统并且能够检索识别的时间为交付时间。</p>
<p>合同当事人对交付方式、交付时间另有约定的，从其约定。</p>
<h4 id="第五十二条"><a href="#第五十二条" class="headerlink" title="第五十二条"></a>第五十二条</h4><p>电子商务当事人可以约定采用快递物流方式交付商品。快递物流服务提供者为电子商务提供快递物流服务，应当遵守法律、行政法规，并应当符合承诺的服务规范和时限。快递物流服务提供者在交付商品时，应当提示收货人当面查验；交由他人代收的，应当经收货人同意。 快递物流服务提供者应当按照规定使用环保包装材料，实现包装材料的减量化和再利用。快递物流服务提供者在提供快递物流服务的同时，可以接受电子商务经营者的委托提供代收货款服务。</p>
<h4 id="第五十三条"><a href="#第五十三条" class="headerlink" title="第五十三条"></a>第五十三条</h4><p>电子商务当事人可以约定采用电子支付方式支付价款。</p>
<p>电子支付服务提供者为电子商务提供电子支付服务，应当遵守国家规定，告知用户电子支付服务的功能、使用方法、注意事项、相关风险和收费标准等事项，不得附加不合理交易条件。电子支付服务提供者应当确保电子支付指令的完整性、一致性、可跟踪稽核和不可篡改。</p>
<p>电子支付服务提供者应当向用户免费提供对账服务以及最近三年的交易记录。</p>
<h4 id="第五十四条"><a href="#第五十四条" class="headerlink" title="第五十四条"></a>第五十四条</h4><p>电子支付服务提供者提供电子支付服务不符合国家有关支付安全管理要求，造成用户损失的，应当承担赔偿责任。</p>
<h4 id="第五十五条"><a href="#第五十五条" class="headerlink" title="第五十五条"></a>第五十五条</h4><p>用户在发出支付指令前，应当核对支付指令所包含的金额、收款人等完整信息。</p>
<p>支付指令发生错误的，电子支付服务提供者应当及时查找原因，并采取相关措施予以纠正。造成用户损失的，电子支付服务提供者应当承担赔偿责任，但能够证明支付错误非自身原因造成的除外。</p>
<h4 id="第五十六条"><a href="#第五十六条" class="headerlink" title="第五十六条"></a>第五十六条</h4><p>电子支付服务提供者完成电子支付后，应当及时准确地向用户提供符合约定方式的确认支付的信息。</p>
<h4 id="第五十七条"><a href="#第五十七条" class="headerlink" title="第五十七条"></a>第五十七条</h4><p>用户应当妥善保管交易密码、电子签名数据等安全工具。用户发现安全工具遗失、被盗用或者未经授权的支付的，应当及时通知电子支付服务提供者。</p>
<p>未经授权的支付造成的损失，由电子支付服务提供者承担；电子支付服务提供者能够证明未经授权的支付是因用户的过错造成的，不承担责任。</p>
<p>电子支付服务提供者发现支付指令未经授权，或者收到用户支付指令未经授权的通知时，应当立即采取措施防止损失扩大。电子支付服务提供者未及时采取措施导致损失扩大的，对损失扩大部分承担责任。</p>
<h2 id="第四章-电子商务争议解决"><a href="#第四章-电子商务争议解决" class="headerlink" title="第四章 电子商务争议解决"></a>第四章 电子商务争议解决</h2><h4 id="第五十八条"><a href="#第五十八条" class="headerlink" title="第五十八条"></a>第五十八条</h4><p>国家鼓励电子商务平台经营者建立有利于电子商务发展和消费者权益保护的商品、服务质量担保机制。</p>
<p>电子商务平台经营者与平台内经营者协议设立消费者权益保证金的，双方应当就消费者权益保证金的提取数额、管理、使用和退还办法等作出明确约定。</p>
<p>消费者要求电子商务平台经营者承担先行赔偿责任以及电子商务平台经营者赔偿后向平台内经营者的追偿，适用《中华人民共和国消费者权益保护法》的有关规定。</p>
<h4 id="第五十九条"><a href="#第五十九条" class="headerlink" title="第五十九条"></a>第五十九条</h4><p>电子商务经营者应当建立便捷、有效的投诉、举报机制，公开投诉、举报方式等信息，及时受理并处理投诉、举报。</p>
<h4 id="第六十条"><a href="#第六十条" class="headerlink" title="第六十条"></a>第六十条</h4><p>电子商务争议可以通过协商和解，请求消费者组织、行业协会或者其他依法成立的调解组织调解，向有关部门投诉，提请仲裁，或者提起诉讼等方式解决。</p>
<h4 id="第六十一条"><a href="#第六十一条" class="headerlink" title="第六十一条"></a>第六十一条</h4><p>消费者在电子商务平台购买商品或者接受服务，与平台内经营者发生争议时，电子商务平台经营者应当积极协助消费者维护合法权益。</p>
<h4 id="第六十二条"><a href="#第六十二条" class="headerlink" title="第六十二条"></a>第六十二条</h4><p>在电子商务争议处理中，电子商务经营者应当提供原始合同和交易记录。因电子商务经营者丢失、伪造、篡改、销毁、隐匿或者拒绝提供前述资料，致使人民法院、仲裁机构或者有关机关无法查明事实的，电子商务经营者应当承担相应的法律责任。</p>
<h4 id="第六十三条"><a href="#第六十三条" class="headerlink" title="第六十三条"></a>第六十三条</h4><p>电子商务平台经营者可以建立争议在线解决机制，制定并公示争议解决规则，根据自愿原则，公平、公正地解决当事人的争议。</p>
<h2 id="第五章-电子商务促进"><a href="#第五章-电子商务促进" class="headerlink" title="第五章 电子商务促进"></a>第五章 电子商务促进</h2><h4 id="第六十四条"><a href="#第六十四条" class="headerlink" title="第六十四条"></a>第六十四条</h4><p>国务院和省、自治区、直辖市人民政府应当将电子商务发展纳入国民经济和社会发展规划，制定科学合理的产业政策，促进电子商务创新发展。</p>
<h4 id="第六十五条"><a href="#第六十五条" class="headerlink" title="第六十五条"></a>第六十五条</h4><p>国务院和县级以上地方人民政府及其有关部门应当采取措施，支持、推动绿色包装、仓储、运输，促进电子商务绿色发展。</p>
<h4 id="第六十六条"><a href="#第六十六条" class="headerlink" title="第六十六条"></a>第六十六条</h4><p>国家推动电子商务基础设施和物流网络建设，完善电子商务统计制度，加强电子商务标准体系建设。</p>
<h4 id="第六十七条"><a href="#第六十七条" class="headerlink" title="第六十七条"></a>第六十七条</h4><p>国家推动电子商务在国民经济各个领域的应用，支持电子商务与各产业融合发展。</p>
<h4 id="第六十八条"><a href="#第六十八条" class="headerlink" title="第六十八条"></a>第六十八条</h4><p>国家促进农业生产、加工、流通等环节的互联网技术应用，鼓励各类社会资源加强合作，促进农村电子商务发展，发挥电子商务在精准扶贫中的作用。</p>
<h4 id="第六十九条"><a href="#第六十九条" class="headerlink" title="第六十九条"></a>第六十九条</h4><p>国家维护电子商务交易安全，保护电子商务用户信息，鼓励电子商务数据开发应用，保障电子商务数据依法有序自由流动。国家采取措施推动建立公共数据共享机制，促进电子商务经营者依法利用公共数据。</p>
<h4 id="第七十条"><a href="#第七十条" class="headerlink" title="第七十条"></a>第七十条</h4><p>国家支持依法设立的信用评价机构开展电子商务信用评价，向社会提供电子商务信用评价服务。</p>
<h4 id="第七十一条"><a href="#第七十一条" class="headerlink" title="第七十一条"></a>第七十一条</h4><p>国家促进跨境电子商务发展，建立健全适应跨境电子商务特点的海关、税收、进出境检验检疫、支付结算等管理制度，提高跨境电子商务各环节便利化水平，支持跨境电子商务平台经营者等为跨境电子商务提供仓储物流、报关、报检等服务。</p>
<p>国家支持小型微型企业从事跨境电子商务。</p>
<h4 id="第七十二条"><a href="#第七十二条" class="headerlink" title="第七十二条"></a>第七十二条</h4><p>国家进出口管理部门应当推进跨境电子商务海关申报、纳税、检验检疫等环节的综合服务和监管体系建设，优化监管流程，推动实现信息共享、监管互认、执法互助，提高跨境电子商务服务和监管效率。跨境电子商务经营者可以凭电子单证向国家进出口管理部门办理有关手续。</p>
<h4 id="第七十三条"><a href="#第七十三条" class="headerlink" title="第七十三条"></a>第七十三条</h4><p>国家推动建立与不同国家、地区之间跨境电子商务的交流合作，参与电子商务国际规则的制定，促进电子签名、电子身份等国际互认。国家推动建立与不同国家、地区之间的跨境电子商务争议解决机制。</p>
<h2 id="第六章-法律责任"><a href="#第六章-法律责任" class="headerlink" title="第六章 法律责任"></a>第六章 法律责任</h2><h4 id="第七十四条"><a href="#第七十四条" class="headerlink" title="第七十四条"></a>第七十四条</h4><p>电子商务经营者销售商品或者提供服务，不履行合同义务或者履行合同义务不符合约定，或者造成他人损害的，依法承担民事责任。</p>
<h4 id="第七十五条"><a href="#第七十五条" class="headerlink" title="第七十五条"></a>第七十五条</h4><p>电子商务经营者违反本法第十二条、第十三条规定，未取得相关行政许可从事经营活动，或者销售、提供法律、行政法规禁止交易的商品、服务，或者不履行本法第二十五条规定的信息提供义务，电子商务平台经营者违反本法第四十六条规定，采取集中交易方式进行交易，或者进行标准化合约交易的，依照有关法律、行政法规的规定处罚。</p>
<h4 id="第七十六条"><a href="#第七十六条" class="headerlink" title="第七十六条"></a>第七十六条</h4><p>电子商务经营者违反本法规定，有下列行为之一的，由市场监督管理部门责令限期改正，可以处一万元以下的罚款，对其中的电子商务平台经营者，依照本法第八十一条第一款的规定处罚：</p>
<ul>
<li>（一）未在首页显著位置公示营业执照信息、行政许可信息、属于不需要办理市场主体登记情形等信息,或者上述信息的链接标识的；</li>
<li>（二）未在首页显著位置持续公示终止电子商务的有关信息的；</li>
<li>（三）未明示用户信息查询、更正、删除以及用户注销的方式、程序，或者对用户信息查询、更正、删除以及用户注销设置不合理条件的。</li>
</ul>
<p>电子商务平台经营者对违反前款规定的平台内经营者未采取必要措施的，由市场监督管理部门责令限期改正，可以处二万元以上十万元以下的罚款。</p>
<h4 id="第七十七条"><a href="#第七十七条" class="headerlink" title="第七十七条"></a>第七十七条</h4><p>电子商务经营者违反本法第十八条第一款规定提供搜索结果，或者违反本法第十九条规定搭售商品、服务的，由市场监督管理部门责令限期改正，没收<br>违法所得，可以并处五万元以上二十万元以下的罚款；情节严重的，并处二十万元以上五十万元以下的罚款。</p>
<h4 id="第七十八条"><a href="#第七十八条" class="headerlink" title="第七十八条"></a>第七十八条</h4><p>电子商务经营者违反本法第二十一条规定，未向消费者明示押金退还的方式、程序，对押金退还设置不合理条件，或者不及时退还押金的，由有关主管部门责令限期改正，可以处五万元以上二十万元以下的罚款；情节严重的，处二十万元以上五十万元以下的罚款。</p>
<h4 id="第七十九条"><a href="#第七十九条" class="headerlink" title="第七十九条"></a>第七十九条</h4><p>电子商务经营者违反法律、行政法规有关个人信息保护的规定，或者不履行本法第三十条和有关法律、行政法规规定的网络安全保障义务的，依照《中华人民共和国网络安全法》等法律、行政法规的规定处罚。</p>
<h4 id="第八十条"><a href="#第八十条" class="headerlink" title="第八十条"></a>第八十条</h4><p>电子商务平台经营者有下列行为之一的，由有关主管部门责令限期改正；逾期不改正的，处二万元以上十万元以下的罚款；情节严重的，责令停业整顿， 并处十万元以上五十万元以下的罚款：</p>
<ul>
<li>（一）不履行本法第二十七条规定的核验、登记义务的；</li>
<li>（二）不按照本法第二十八条规定向市场监督管理部门、税务部门报送有关信息 的； </li>
<li>（三）不按照本法第二十九条规定对违法情形采取必要的处置措施，或者未向有关主管部门报告的；</li>
<li>（四）不履行本法第三十一条规定的商品和服务信息、交易信息保存义务的。</li>
</ul>
<p>法律、行政法规对前款规定的违法行为的处罚另有规定的，依照其规定。</p>
<h4 id="第八十一条"><a href="#第八十一条" class="headerlink" title="第八十一条"></a>第八十一条</h4><p>电子商务平台经营者违反本法规定，有下列行为之一的，由市场监督管理部门责令限期改正，可以处二万元以上十万元以下的罚款；情节严重的，处十万元以上五十万元以下的罚款：</p>
<ul>
<li>（一）未在首页显著位置持续公示平台服务协议、交易规则信息或者上述信息的 链接标识的；</li>
<li>（二）修改交易规则未在首页显著位置公开征求意见，未按照规定的时间提前公示修改内容，或者阻止平台内经营者退出的；</li>
<li>（三）未以显著方式区分标记自营业务和平台内经营者开展的业务的； </li>
<li>（四）未为消费者提供对平台内销售的商品或者提供的服务进行评价的途径，或者擅自删除消费者的评价的。</li>
</ul>
<p>电子商务平台经营者违反本法第四十条规定，对竞价排名的商品或者服务未显著标明“广告”的，依照《中华人民共和国广告法》的规定处罚。</p>
<h4 id="第八十二条"><a href="#第八十二条" class="headerlink" title="第八十二条"></a>第八十二条</h4><p>电子商务平台经营者违反本法第三十五条规定，对平台内经营者在平台内的交易、交易价格或者与其他经营者的交易等进行不合理限制或者附加不合理条件，或者向平台内经营者收取不合理费用的，由市场监督管理部门责令限期改正，可以处五万元以上五十万元以下的罚款；情节严重的，处五十万元以上二百万元以下 的罚款。</p>
<h4 id="第八十三条"><a href="#第八十三条" class="headerlink" title="第八十三条"></a>第八十三条</h4><p>电子商务平台经营者违反本法第三十八条规定，对平台内经营者侵害消费者合法权益行为未采取必要措施，或者对平台内经营者未尽到资质资格审核义务，或者对消费者未尽到安全保障义务的，由市场监督管理部门责令限期改正，可以处五万元以上五十万元以下的罚款；情节严重的，责令停业整顿，并处五十万元以上二百万元以下的罚款。</p>
<h4 id="第八十四条"><a href="#第八十四条" class="headerlink" title="第八十四条"></a>第八十四条</h4><p>电子商务平台经营者违反本法第四十二条、第四十五条规定，对平台内经营者实施侵犯知识产权行为未依法采取必要措施的，由有关知识产权行政部门责令限期改正；逾期不改正的，处五万元以上五十万元以下的罚款；情节严重的，处五十万元以上二百万元以下的罚款。</p>
<h4 id="第八十五条"><a href="#第八十五条" class="headerlink" title="第八十五条"></a>第八十五条</h4><p>电子商务经营者违反本法规定，销售的商品或者提供的服务不符合保障人身、财产安全的要求，实施虚假或者引人误解的商业宣传等不正当竞争行为，滥用市场支配地位，或者实施侵犯知识产权、侵害消费者权益等行为的，依照有关法律的规定处罚。</p>
<h4 id="第八十六条"><a href="#第八十六条" class="headerlink" title="第八十六条"></a>第八十六条</h4><p>电子商务经营者有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。</p>
<h4 id="第八十七条"><a href="#第八十七条" class="headerlink" title="第八十七条"></a>第八十七条</h4><p>依法负有电子商务监督管理职责的部门的工作人员，玩忽职守、滥用职权、徇私舞弊，或者泄露、出售或者非法向他人提供在履行职责中所知悉的个人信息、隐私和商业秘密的，依法追究法律责任。</p>
<h4 id="第八十八条"><a href="#第八十八条" class="headerlink" title="第八十八条"></a>第八十八条</h4><p>违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。</p>
<p><a class="link"   href="https://github.com/blusewang/blog/files/5779079/default.pdf" >中华人民共和国电子商务法.pdf<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>电子商务法</tag>
      </tags>
  </entry>
  <entry>
    <title>解决FreeBSD上的程序崩溃</title>
    <url>/2021/02/27/freebsd-lldb-debug-programe/</url>
    <content><![CDATA[<h2 id="第一步-开启核心转储"><a href="#第一步-开启核心转储" class="headerlink" title="第一步:开启核心转储"></a>第一步:开启核心转储</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kern.corefile=/var/db/coredump/%N.core</span><br><span class="line">kern.coredump=1</span><br><span class="line">kern.nodump_coredump=1</span><br><span class="line">kern.sugid_coredump=1</span><br></pre></td></tr></table></figure>
<p>当前设置,会让进程崩溃后,将核心转储至<code>/var/db/coredump/</code>文件夹下.</p>
<h2 id="第二步-等待"><a href="#第二步-等待" class="headerlink" title="第二步:等待"></a>第二步:等待</h2><p>定期检查<code>/var/log/message</code>文件,等待程序崩溃事件的到来.</p>
<h2 id="第三步-调试"><a href="#第三步-调试" class="headerlink" title="第三步:调试"></a>第三步:调试</h2><ul>
<li>使用<code>lldb</code>打开<code>core</code>文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lldb -c /var/db/coredump/mosquitto.core -- /usr/local/sbin/mosquitto</span><br></pre></td></tr></table></figure></li>
<li>打开,进入后执行<code>bt</code>就看到详细错误了.非常简单.</li>
</ul>
<p>过程如图:<br><img src="https://user-images.githubusercontent.com/1764005/109384031-354e3200-7925-11eb-802d-0ca220e55443.png" alt="image"></p>
<p>这表明是<code>libgdb.so</code>扩展里,调用<code>strcmp</code>函数时,参数给错了!</p>
<p>so easy!~</p>
]]></content>
      <tags>
        <tag>mosquitto</tag>
        <tag>FreeBSD</tag>
        <tag>lldb</tag>
      </tags>
  </entry>
</search>
